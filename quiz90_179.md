# Coding Interview in Java

August 1 st, 2016

## 90 Maximum Gap

Given an unsorted array, find the maximum difference between the successive ele-
ments in its sorted form.

Try to solve it in linear time/space. Return 0 if the array contains less than 2 ele-
ments. You may assume all elements in the array are non-negative integers and fit in
the 32 -bit signed integer range.

**90.1 Analysis**

We can use a bucket-sort like algorithm to solve this problem in time of O(n) and space
O(n). The basic idea is to project each element of the array to an array of buckets. Each
bucket tracks the maximum and minimum elements. Finally, scanning the bucket list,
we can get the maximum gap.

The key part is to get the interval:

From: interval *(num[i] - min) = 0 and interval* (max -num[i]) = n
interval = num.length / (max - min)

See the internal comment for more details.

**90.2 Java Solution**

class Bucket{
int low;
int high;
public Bucket(){
low = -1;
high = -1;
}
}

public int maximumGap(int[] num) {
if(num == null || num.length < 2){
return 0;
}

```
int max = num[0];
int min = num[0];
for(int i=1; i<num.length; i++){
max = Math.max(max, num[i]);
```
221 | 677


90 Maximum Gap

```
min = Math.min(min, num[i]);
}
```
```
// initialize an array of buckets
Bucket[] buckets = new Bucket[num.length+1]; //project to (0 - n)
for(int i=0; i<buckets.length; i++){
buckets[i] = new Bucket();
}
```
```
double interval = (double) num.length / (max - min);
//distribute every number to a bucket array
for(int i=0; i<num.length; i++){
int index = (int) ((num[i] - min)* interval);
```
```
if(buckets[index].low == -1){
buckets[index].low = num[i];
buckets[index].high = num[i];
}else{
buckets[index].low = Math.min(buckets[index].low, num[i]);
buckets[index].high = Math.max(buckets[index].high, num[i]);
}
}
```
```
//scan buckets to find maximum gap
int result = 0;
int prev = buckets[0].high;
for(int i=1; i<buckets.length; i++){
if(buckets[i].low != -1){
result = Math.max(result, buckets[i].low-prev);
prev = buckets[i].high;
}
```
```
}
```
return result;
}

222 | 677 Program Creek


## 91 Sort Colors

Given an array with n objects colored red, white or blue, sort them so that objects of
the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0 , 1 , and 2 to represent the color red, white, and blue
respectively.

**91.1 Java Solution 1 - Counting Sort**

Check out this animation to understand how counting sort works.

public void sortColors(int[] nums) {
if(nums==null||nums.length<2){
return;
}

```
int[] countArray = new int[3];
for(int i=0; i<nums.length; i++){
countArray[nums[i]]++;
}
```
```
for(int i=1; i<=2; i++){
countArray[i]=countArray[i-1]+countArray[i];
}
```
```
int[] sorted = new int[nums.length];
for(int i=0;i<nums.length; i++){
int index = countArray[nums[i]]-1;
countArray[nums[i]] = countArray[nums[i]]-1;
sorted[index]=nums[i];
}
```
System.arraycopy(sorted, 0, nums, 0, nums.length);
}

**91.2 Java Solution 2 - Improved Counting Sort**

In solution 1 , two arrays are created. One is for counting, and the other is for storing
the sorted array (space is O(n)). We can improve the solution so that it only uses

constant space. Since we already get the count of each element, we can directly project
them to the original array, instead of creating a new one.

223 | 677


91 Sort Colors

public void sortColors(int[] nums) {
if(nums==null||nums.length<2){
return;
}

```
int[] countArray = new int[3];
for(int i=0; i<nums.length; i++){
countArray[nums[i]]++;
}
```
int j = 0;
int k = 0;
while(j<=2){
if(countArray[j]!=0){
nums[k++]=j;
countArray[j] = countArray[j]-1;
}else{
j++;
}
}
}

224 | 677 Program Creek


## 92 Merge Intervals

Given a collection of intervals, merge all overlapping intervals.

For example, Given [ 1 , 3 ],[ 2 , 6 ],[ 8 , 10 ],[ 15 , 18 ], return [ 1 , 6 ],[ 8 , 10 ],[ 15 , 18 ].

**92.1 Analysis**

The key to solve this problem is defining a Comparator first to sort the arraylist of
Intevals.

**92.2 Java Solution**

public List<Interval> merge(List<Interval> intervals) {
List<Interval> result = new ArrayList<Interval>();

```
if(intervals==null||intervals.size()==0)
return result;
```
```
Collections.sort(intervals, new Comparator<Interval>(){
public int compare(Interval i1, Interval i2){
if(i1.start!=i2.start)
return i1.start-i2.start;
else
return i1.end-i2.end;
}
});
```
```
Interval pre = intervals.get(0);
for(int i=0; i<intervals.size(); i++){
Interval curr = intervals.get(i);
if(curr.start>pre.end){
result.add(pre);
pre = curr;
}else{
Interval merged = new Interval(pre.start, Math.max(pre.end,
curr.end));
pre = merged;
}
}
result.add(pre);
```
```
return result;
```
225 | 677


92 Merge Intervals

### }

226 | 677 Program Creek


## 93 Insert Interval

Problem:

```
Given a set of non-overlapping & sorted intervals, insert a new interval into the intervals
(merge if necessary).
```
Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as
[1,2],[3,10],[12,16].

This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].

**93.1 Thoughts of This Problem**

Quickly summarize 3 cases. Whenever there is intersection, created a new interval.

**93.2 Java Solution**

227 | 677


93 Insert Interval

### /**

* Definition for an interval.
* public class Interval {
* int start;
* int end;
* Interval() { start = 0; end = 0; }
* Interval(int s, int e) { start = s; end = e; }
* }
*/
public class Solution {
public ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval
newInterval) {

```
ArrayList<Interval> result = new ArrayList<Interval>();
```
```
for(Interval interval: intervals){
if(interval.end < newInterval.start){
result.add(interval);
}else if(interval.start > newInterval.end){
result.add(newInterval);
newInterval = interval;
}else if(interval.end >= newInterval.start || interval.start <=
newInterval.end){
newInterval = new Interval(Math.min(interval.start,
newInterval.start), Math.max(newInterval.end, interval.end));
}
}
```
```
result.add(newInterval);
```
return result;
}
}

228 | 677 Program Creek


## 94 Implement a Stack Using an Array in Java

This post shows how to implement a stack by using an array.
The requirements of the stack are: 1 ) the stack has a constructor which accept a
number to initialize its size, 2 ) the stack can hold any type of elements, 3 ) the stack
has a push() and a pop() method.

I remember there is a similar example in the "Effective Java" book written by Joshua
Bloch, but not sure how the example is used. So I just write one and then read the
book, and see if I miss anything.

**94.1 A Simple Stack Implementation**

public class Stack<E> {
private E[] arr = null;
private int CAP;
private int top = -1;
private int size = 0;

```
@SuppressWarnings("unchecked")
public Stack(int cap) {
this.CAP = cap;
this.arr = (E[]) new Object[cap];
}
```
```
public E pop() {
if(this.size == 0){
return null;
}
```
```
this.size--;
E result = this.arr[top];
this.arr[top] = null;//prevent memory leaking
this.top--;
```
```
return result;
}
```
```
public boolean push(E e) {
if (!isFull())
return false;
```
229 | 677


94 Implement a Stack Using an Array in Java

```
this.size++;
this.arr[++top] = e;
return false;
}
```
```
public boolean isFull() {
if (this.size == this.CAP)
return false;
return true;
}
```
```
public String toString() {
if(this.size==0){
return null;
}
```
```
StringBuilder sb = new StringBuilder();
for(int i=0; i<this.size; i++){
sb.append(this.arr[i] + ", ");
}
```
```
sb.setLength(sb.length()-2);
return sb.toString();
}
```
```
public static void main(String[] args) {
```
```
Stack<String> stack = new Stack<String>(11);
stack.push("hello");
stack.push("world");
```
```
System.out.println(stack);
```
```
stack.pop();
System.out.println(stack);
```
stack.pop();
System.out.println(stack);
}
}

Output:

hello, world
hello
null

230 | 677 Program Creek


```
94 Implement a Stack Using an Array in Java
```
**94.2 Information from "Effective Java"**

It turns out I don’t need to improve anything. There are some naming differences but
overall my method is ok.

This example occurs twice in "Effective Java". In the first place, the stack example is
used to illustrate memory leak. In the second place, the example is used to illustrate
when we can suppress unchecked warnings.
Do you wonder how to implement a queue by using an array?

Program Creek 231 | 677



## 95 Implement Stack using Queues

Implement the following operations of a stack using queues. push(x) – Push element
x onto stack. pop() – Removes the element on top of the stack. top() – Get the top
element. empty() – Return whether the stack is empty.

Note: only standard queue operations are allowed, i.e., poll(), offer(), peek(), size()
and isEmpty() in Java.

**95.1 Analysis**

This problem can be solved by using two queues.

**95.2 Java Solution**

class MyStack {
LinkedList<Integer> queue1 = new LinkedList<Integer>();
LinkedList<Integer> queue2 = new LinkedList<Integer>();

```
// Push element x onto stack.
public void push(int x) {
if(empty()){
queue1.offer(x);
}else{
if(queue1.size()>0){
queue2.offer(x);
int size = queue1.size();
while(size>0){
queue2.offer(queue1.poll());
size--;
}
}else if(queue2.size()>0){
queue1.offer(x);
int size = queue2.size();
while(size>0){
queue1.offer(queue2.poll());
size--;
}
}
}
}
```
233 | 677


95 Implement Stack using Queues

```
// Removes the element on top of the stack.
public void pop() {
if(queue1.size()>0){
queue1.poll();
}else if(queue2.size()>0){
queue2.poll();
}
}
```
```
// Get the top element.
public int top() {
if(queue1.size()>0){
return queue1.peek();
}else if(queue2.size()>0){
return queue2.peek();
}
return 0;
}
```
// Return whether the stack is empty.
public boolean empty() {
return queue1.isEmpty() & queue2.isEmpty();
}
}

234 | 677 Program Creek


## 96 Implement Queue using Stacks Contents

Implement the following operations of a queue using stacks.

push(x) – Push element x to the back of queue. pop() – Removes the element from

in front of queue. peek() – Get the front element. empty() – Return whether the queue
is empty.

**96.1 Java Solution**

class MyQueue {

```
Stack<Integer> temp = new Stack<Integer>();
Stack<Integer> value = new Stack<Integer>();
```
```
// Push element x to the back of queue.
public void push(int x) {
if(value.isEmpty()){
value.push(x);
}else{
while(!value.isEmpty()){
temp.push(value.pop());
}
```
```
value.push(x);
```
```
while(!temp.isEmpty()){
value.push(temp.pop());
}
}
}
```
```
// Removes the element from in front of queue.
public void pop() {
value.pop();
}
```
```
// Get the front element.
public int peek() {
return value.peek();
}
```
```
// Return whether the queue is empty.
```
235 | 677


96 Implement Queue using Stacks

public boolean empty() {
return value.isEmpty();
}
}

236 | 677 Program Creek


## 97 Implement a Queue using an Array in Java

There following Java code shows how to implement a queue without using any extra
data structures in Java. We can implement a queue by using an array.

import java.lang.reflect.Array;
import java.util.Arrays;

public class Queue<E> {

```
E[] arr;
int head = -1;
int tail = -1;
int size;
```
```
public Queue(Class<E> c, int size) {
E[] newInstance = (E[]) Array.newInstance(c, size);
this.arr = newInstance;
this.size = 0;
}
```
```
boolean push(E e) {
if (size == arr.length)
return false;
```
```
head = (head + 1) % arr.length;
arr[head] = e;
size++;
```
```
if(tail == -1){
tail = head;
}
```
237 | 677


97 Implement a Queue using an Array in Java

```
return true;
}
```
```
boolean pop() {
if (size == 0) {
return false;
}
```
```
E result = arr[tail];
arr[tail] = null;
size--;
tail = (tail+1)%arr.length;
```
```
if (size == 0) {
head = -1;
tail = -1;
}
```
```
return true;
}
```
```
E peek(){
if(size==0)
return null;
```
```
return arr[tail];
}
```
```
public int size() {
return this.size;
}
```
```
public String toString() {
return Arrays.toString(this.arr);
}
```
public static void main(String[] args) {
Queue<Integer> q = new Queue<Integer>(Integer.class, 5);
q.push(1);
q.push(2);
q.push(3);
q.push(4);
q.push(5);
q.pop();
q.push(6);
System.out.println(q);
}
}

238 | 677 Program Creek


## 98 Implement Trie (Prefix Tree)

Implement a trie with insert, search, and startsWith methods.

**98.1 Java Solution 1**

A trie node should contains the character, its children and the flag that marks if it is a

leaf node. You can use this diagram to walk though the Java solution.

class TrieNode {
char c;
HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();
boolean isLeaf;

```
public TrieNode() {}
```
public TrieNode(char c){
this.c = c;
}
}

public class Trie {
private TrieNode root;

```
public Trie() {
root = new TrieNode();
}
```
239 | 677


98 Implement Trie (Prefix Tree)

```
// Inserts a word into the trie.
public void insert(String word) {
HashMap<Character, TrieNode> children = root.children;
```
```
for(int i=0; i<word.length(); i++){
char c = word.charAt(i);
```
```
TrieNode t;
if(children.containsKey(c)){
t = children.get(c);
}else{
t = new TrieNode(c);
children.put(c, t);
}
```
```
children = t.children;
```
```
//set leaf node
if(i==word.length()-1)
t.isLeaf = true;
}
}
```
```
// Returns if the word is in the trie.
public boolean search(String word) {
TrieNode t = searchNode(word);
```
```
if(t != null && t.isLeaf)
return true;
else
return false;
}
```
```
// Returns if there is any word in the trie
// that starts with the given prefix.
public boolean startsWith(String prefix) {
if(searchNode(prefix) == null)
return false;
else
return true;
}
```
```
public TrieNode searchNode(String str){
Map<Character, TrieNode> children = root.children;
TrieNode t = null;
for(int i=0; i<str.length(); i++){
char c = str.charAt(i);
if(children.containsKey(c)){
t = children.get(c);
```
240 | 677 Program Creek


```
98 Implement Trie (Prefix Tree)
```
```
children = t.children;
}else{
return null;
}
}
```
return t;
}
}

**98.2 Java Solution 2 - Improve Performance by Using an**

**Array**

Each trie node can only contains ’a’-’z’ characters. So we can use a small array to store
the character.

class TrieNode {
TrieNode[] arr;
boolean isEnd;
// Initialize your data structure here.
public TrieNode() {
this.arr = new TrieNode[26];
}

}

public class Trie {
private TrieNode root;

```
public Trie() {
root = new TrieNode();
}
```
```
// Inserts a word into the trie.
public void insert(String word) {
TrieNode p = root;
for(int i=0; i<word.length(); i++){
char c = word.charAt(i);
int index = c-’a’;
if(p.arr[index]==null){
TrieNode temp = new TrieNode();
p.arr[index]=temp;
p = temp;
}else{
p=p.arr[index];
}
}
p.isEnd=true;
```
Program Creek 241 | 677


98 Implement Trie (Prefix Tree)

### }

```
// Returns if the word is in the trie.
public boolean search(String word) {
TrieNode p = searchNode(word);
if(p==null){
return false;
}else{
if(p.isEnd)
return true;
}
```
```
return false;
}
```
```
// Returns if there is any word in the trie
// that starts with the given prefix.
public boolean startsWith(String prefix) {
TrieNode p = searchNode(prefix);
if(p==null){
return false;
}else{
return true;
}
}
```
```
public TrieNode searchNode(String s){
TrieNode p = root;
for(int i=0; i<s.length(); i++){
char c= s.charAt(i);
int index = c-’a’;
if(p.arr[index]!=null){
p = p.arr[index];
}else{
return null;
}
}
```
```
if(p==root)
return null;
```
return p;
}
}

242 | 677 Program Creek


## 99 Add and Search Word Data structure design

Design a data structure that supports the following two operations:

void addWord(word)
bool search(word)

search(word) can search a literal word or a regular expression string containing only
letters a-z or .. A. means it can represent any one letter.

**99.1 Java Solution 1**

This problem is similar with Implement Trie. The solution 1 below uses the same
definition of a trie node. To handle the "." case for this problem, we need to search all
possible paths, instead of one path.

TrieNode

class TrieNode{
char c;
HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();
boolean isLeaf;

```
public TrieNode() {}
```
public TrieNode(char c){
this.c = c;
}
}

WordDictionary

public class WordDictionary {
private TrieNode root;

```
public WordDictionary(){
root = new TrieNode();
}
```
```
// Adds a word into the data structure.
public void addWord(String word) {
HashMap<Character, TrieNode> children = root.children;
```
243 | 677


99 Add and Search Word Data structure design

```
for(int i=0; i<word.length(); i++){
char c = word.charAt(i);
```
```
TrieNode t = null;
if(children.containsKey(c)){
t = children.get(c);
}else{
t = new TrieNode(c);
children.put(c,t);
}
```
```
children = t.children;
```
```
if(i == word.length()-1){
t.isLeaf = true;
}
}
}
```
```
// Returns if the word is in the data structure. A word could
// contain the dot character ’.’ to represent any one letter.
public boolean search(String word) {
return dfsSearch(root.children, word, 0);
```
```
}
```
```
public boolean dfsSearch(HashMap<Character, TrieNode> children, String
word, int start) {
if(start == word.length()){
if(children.size()==0)
return true;
else
return false;
}
```
```
char c = word.charAt(start);
```
```
if(children.containsKey(c)){
if(start == word.length()-1 && children.get(c).isLeaf){
return true;
}
```
```
return dfsSearch(children.get(c).children, word, start+1);
}else if(c == ’.’){
boolean result = false;
for(Map.Entry<Character, TrieNode> child: children.entrySet()){
if(start == word.length()-1 && child.getValue().isLeaf){
return true;
}
```
244 | 677 Program Creek


```
99 Add and Search Word Data structure design
```
```
//if any path is true, set result to be true;
if(dfsSearch(child.getValue().children, word, start+1)){
result = true;
}
}
```
return result;
}else{
return false;
}
}
}

**99.2 Java Solution 2 - Using Array Instead of HashMap**

class TrieNode{
TrieNode[] arr;
boolean isLeaf;

public TrieNode(){
arr = new TrieNode[26];
}
}

public class WordDictionary {
TrieNode root;

```
public WordDictionary(){
root = new TrieNode();
}
// Adds a word into the data structure.
public void addWord(String word) {
TrieNode p= root;
for(int i=0; i<word.length(); i++){
char c=word.charAt(i);
int index = c-’a’;
if(p.arr[index]==null){
TrieNode temp = new TrieNode();
p.arr[index]=temp;
p=temp;
}else{
p=p.arr[index];
}
}
```
```
p.isLeaf=true;
```
Program Creek 245 | 677


99 Add and Search Word Data structure design

### }

```
// Returns if the word is in the data structure. A word could
// contain the dot character ’.’ to represent any one letter.
public boolean search(String word) {
return dfsSearch(root, word, 0);
}
```
```
public boolean dfsSearch(TrieNode p, String word, int start) {
if (p.isLeaf && start == word.length())
return true;
```
```
if (start >= word.length())
return false;
```
```
char c = word.charAt(start);
```
```
if (c == ’.’) {
boolean tResult = false;
for (int j = 0; j < 26; j++) {
if (p.arr[j] != null) {
if (dfsSearch(p.arr[j], word, start + 1)) {
tResult = true;
break;
}
}
}
```
```
if (tResult)
return true;
} else {
int index = c - ’a’;
```
```
if (p.arr[index] != null) {
return dfsSearch(p.arr[index], word, start + 1);
} else {
return false;
}
}
```
return false;
}
}

246 | 677 Program Creek


## 100 Range Sum Query Mutable

Given an integer array nums, find the sum of the elements between indices i and j (i

≤j), inclusive. The update(i, val) function modifies nums by updating the element at
index i to val.

**100.1 Java Solution**

class TreeNode{
int start;
int end;
int sum;
TreeNode leftChild;
TreeNode rightChild;

```
public TreeNode(int left, int right, int sum){
this.start=left;
this.end=right;
this.sum=sum;
}
public TreeNode(int left, int right){
this.start=left;
```
247 | 677


100 Range Sum Query Mutable

this.end=right;
this.sum=0;
}
}

public class NumArray {
TreeNode root = null;

```
public NumArray(int[] nums) {
if(nums==null || nums.length==0)
return;
```
```
this.root = buildTree(nums, 0, nums.length-1);
}
```
```
void update(int i, int val) {
updateHelper(root, i, val);
}
```
```
void updateHelper(TreeNode root, int i, int val){
if(root==null)
return;
```
```
int mid = root.start + (root.end-root.start)/2;
if(i<=mid){
updateHelper(root.leftChild, i, val);
}else{
updateHelper(root.rightChild, i, val);
}
```
```
if(root.start==root.end&& root.start==i){
root.sum=val;
return;
}
```
```
root.sum=root.leftChild.sum+root.rightChild.sum;
}
```
```
public int sumRange(int i, int j) {
return sumRangeHelper(root, i, j);
}
```
```
public int sumRangeHelper(TreeNode root, int i, int j){
if(root==null || j<root.start || i > root.end ||i>j )
return 0;
```
```
if(i<=root.start && j>=root.end){
return root.sum;
```
248 | 677 Program Creek


```
100 Range Sum Query Mutable
```
### }

```
int mid = root.start + (root.end-root.start)/2;
int result = sumRangeHelper(root.leftChild, i, Math.min(mid, j))
+sumRangeHelper(root.rightChild, Math.max(mid+1, i), j);
```
```
return result;
}
```
```
public TreeNode buildTree(int[] nums, int i, int j){
if(nums==null || nums.length==0|| i>j)
return null;
```
```
if(i==j){
return new TreeNode(i, j, nums[i]);
}
```
```
TreeNode current = new TreeNode(i, j);
```
```
int mid = i + (j-i)/2;
```
```
current.leftChild = buildTree(nums, i, mid);
current.rightChild = buildTree(nums, mid+1, j);
```
```
current.sum = current.leftChild.sum+current.rightChild.sum;
```
return current;
}
}

Program Creek 249 | 677



## 101 The Skyline Problem

**101.1 Analysis**

This problem is essentially a problem of processing 2 *n edges. Each edge has a x-axis
value and a height value. The key part is how to use the height heap to process each

edge.

**101.2 Java Solution**

class Edge {
int x;
int height;
boolean isStart;

public Edge(int x, int height, boolean isStart) {
this.x = x;
this.height = height;
this.isStart = isStart;
}
}

public List<int[]> getSkyline(int[][] buildings) {
List<int[]> result = new ArrayList<int[]>();

```
if (buildings == null || buildings.length == 0
|| buildings[0].length == 0) {
return result;
}
```
```
List<Edge> edges = new ArrayList<Edge>();
```
```
// add all left/right edges
for (int[] building : buildings) {
Edge startEdge = new Edge(building[0], building[2], true);
edges.add(startEdge);
Edge endEdge = new Edge(building[1], building[2], false);
edges.add(endEdge);
}
```
```
// sort edges
```
251 | 677


101 The Skyline Problem

```
Collections.sort(edges, new Comparator<Edge>() {
public int compare(Edge a, Edge b) {
if (a.x != b.x)
return Integer.compare(a.x, b.x);
```
```
if (a.isStart && b.isStart) {
return Integer.compare(b.height, a.height);
}
```
```
if (!a.isStart && !b.isStart) {
return Integer.compare(a.height, b.height);
}
```
```
return a.isStart? -1 : 1;
}
});
```
```
// process edges
PriorityQueue<Integer> heightHeap = new PriorityQueue<Integer>(10,
Collections.reverseOrder());
```
```
for (Edge edge : edges) {
if (edge.isStart) {
if (heightHeap.isEmpty() || edge.height > heightHeap.peek()) {
result.add(new int[] { edge.x, edge.height });
}
heightHeap.add(edge.height);
} else {
heightHeap.remove(edge.height);
```
```
if(heightHeap.isEmpty()){
result.add(new int[] {edge.x, 0});
}else if(edge.height > heightHeap.peek()){
result.add(new int[]{edge.x, heightHeap.peek()});
}
}
}
```
return result;
}

252 | 677 Program Creek


## 102 Clone Graph

Clone an undirected graph. Each node in the graph contains a label and a list of its

neighbors.

**102.1 Java Solution 1**

In this solution,

- a queue is used to do breath first traversal,
- and a map is used to store the visited nodes. It is the map between original node
    and copied node.

It would be helpful if you draw a diagram and visualize the problem.

### /**

```
* Definition for undirected graph.
```
253 | 677


102 Clone Graph

* class UndirectedGraphNode {
* int label;
* ArrayList<UndirectedGraphNode> neighbors;
* UndirectedGraphNode(int x) { label = x; neighbors = new
ArrayList<UndirectedGraphNode>(); }
* };
*/
public class Solution {
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
if(node == null)
return null;

```
LinkedList<UndirectedGraphNode> queue = new
LinkedList<UndirectedGraphNode>();
HashMap<UndirectedGraphNode, UndirectedGraphNode> map =
new
HashMap<UndirectedGraphNode,UndirectedGraphNode>();
```
```
UndirectedGraphNode newHead = new UndirectedGraphNode(node.label);
```
```
queue.add(node);
map.put(node, newHead);
```
```
while(!queue.isEmpty()){
UndirectedGraphNode curr = queue.pop();
ArrayList<UndirectedGraphNode> currNeighbors = curr.neighbors;
```
```
for(UndirectedGraphNode aNeighbor: currNeighbors){
if(!map.containsKey(aNeighbor)){
UndirectedGraphNode copy = new
UndirectedGraphNode(aNeighbor.label);
map.put(aNeighbor,copy);
map.get(curr).neighbors.add(copy);
queue.add(aNeighbor);
}else{
map.get(curr).neighbors.add(map.get(aNeighbor));
}
}
```
}
return newHead;
}
}

**102.2 Java Solution 2**

public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {

254 | 677 Program Creek


```
102 Clone Graph
```
```
if(node == null)
return null;
```
```
LinkedList<UndirectedGraphNode> queue = new
LinkedList<UndirectedGraphNode>();
```
```
HashMap<UndirectedGraphNode,UndirectedGraphNode> map = new
HashMap<UndirectedGraphNode,UndirectedGraphNode>();
```
```
queue.offer(node);
while(!queue.isEmpty()){
UndirectedGraphNode top = queue.poll();
map.put(top, new UndirectedGraphNode(top.label));
```
```
for(UndirectedGraphNode n: top.neighbors){
if(!map.containsKey(n))
queue.offer(n);
}
}
```
```
queue.offer(node);
HashSet<UndirectedGraphNode> set = new HashSet<UndirectedGraphNode>();
set.add(node);
```
```
while(!queue.isEmpty()){
UndirectedGraphNode top = queue.poll();
for(UndirectedGraphNode n: top.neighbors){
if(!set.contains(n)){
queue.offer(n);
set.add(n);
}
map.get(top).neighbors.add(map.get(n));
}
}
```
return map.get(node);
}

Program Creek 255 | 677



## 103 Course Schedule

There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses
may have prerequisites, for example to take course 0 you have to first take course 1 ,
which is expressed as a pair: [ 0 , 1 ]. Given the total number of courses and a list of

prerequisite pairs, is it possible for you to finish all courses?
For example, given 2 and [[ 1 , 0 ]], there are a total of 2 courses to take. To take course
1 you should have finished course 0. So it is possible.
For another example, given 2 and [[ 1 , 0 ],[ 0 , 1 ]], there are a total of 2 courses to take.
To take course 1 you should have finished course 0 , and to take course 0 you should

also have finished course 1. So it is impossible.

**103.1 Analysis**

This problem can be converted to finding if a graph contains a cycle.

**103.2 Java Solution 1 - BFS**

This solution uses breath-first search and it is easy to understand.

public boolean canFinish(int numCourses, int[][] prerequisites) {
if(prerequisites == null){
throw new IllegalArgumentException("illegal prerequisites array");
}

```
int len = prerequisites.length;
```
```
if(numCourses == 0 || len == 0){
return true;
}
```
```
// counter for number of prerequisites
int[] pCounter = new int[numCourses];
for(int i=0; i<len; i++){
pCounter[prerequisites[i][0]]++;
}
```
```
//store courses that have no prerequisites
LinkedList<Integer> queue = new LinkedList<Integer>();
for(int i=0; i<numCourses; i++){
if(pCounter[i]==0){
queue.add(i);
```
257 | 677


103 Course Schedule

### }

### }

```
// number of courses that have no prerequisites
int numNoPre = queue.size();
```
```
while(!queue.isEmpty()){
int top = queue.remove();
for(int i=0; i<len; i++){
// if a course’s prerequisite can be satisfied by a course in queue
if(prerequisites[i][1]==top){
pCounter[prerequisites[i][0]]--;
if(pCounter[prerequisites[i][0]]==0){
numNoPre++;
queue.add(prerequisites[i][0]);
}
}
}
}
```
return numNoPre == numCourses;
}

**103.3 Java Solution 2 - DFS**

public boolean canFinish(int numCourses, int[][] prerequisites) {
if(prerequisites == null){
throw new IllegalArgumentException("illegal prerequisites array");
}

```
int len = prerequisites.length;
```
```
if(numCourses == 0 || len == 0){
return true;
}
```
```
//track visited courses
int[] visit = new int[numCourses];
```
```
// use the map to store what courses depend on a course
HashMap<Integer,ArrayList<Integer>> map = new
HashMap<Integer,ArrayList<Integer>>();
for(int[] a: prerequisites){
if(map.containsKey(a[1])){
map.get(a[1]).add(a[0]);
}else{
ArrayList<Integer> l = new ArrayList<Integer>();
```
258 | 677 Program Creek


```
103 Course Schedule
```
```
l.add(a[0]);
map.put(a[1], l);
}
}
```
```
for(int i=0; i<numCourses; i++){
if(!canFinishDFS(map, visit, i))
return false;
}
```
return true;
}

private boolean canFinishDFS(HashMap<Integer,ArrayList<Integer>> map, int[]
visit, int i){
if(visit[i]==-1)
return false;
if(visit[i]==1)
return true;

```
visit[i]=-1;
if(map.containsKey(i)){
for(int j: map.get(i)){
if(!canFinishDFS(map, visit, j))
return false;
}
}
```
```
visit[i]=1;
```
return true;
}

Topological Sort Video from Coursera.

Program Creek 259 | 677



## 104 Course Schedule II

This is an extension of Course Schedule. This time a valid sequence of courses is

required as output.

**104.1 Analysis**

If we use the DFS solution of Course Schedule, a valid sequence can easily be recorded.

**104.2 Java Solution**

public int[] findOrder(int numCourses, int[][] prerequisites) {
if(prerequisites == null){
throw new IllegalArgumentException("illegal prerequisites array");
}

```
int len = prerequisites.length;
```
```
//if there is no prerequisites, return a sequence of courses
if(len == 0){
int[] res = new int[numCourses];
for(int m=0; m<numCourses; m++){
res[m]=m;
}
return res;
}
```
```
//records the number of prerequisites each course (0,...,numCourses-1)
requires
int[] pCounter = new int[numCourses];
for(int i=0; i<len; i++){
pCounter[prerequisites[i][0]]++;
}
```
```
//stores courses that have no prerequisites
LinkedList<Integer> queue = new LinkedList<Integer>();
for(int i=0; i<numCourses; i++){
if(pCounter[i]==0){
queue.add(i);
}
}
```
261 | 677


104 Course Schedule II

```
int numNoPre = queue.size();
```
```
//initialize result
int[] result = new int[numCourses];
int j=0;
```
```
while(!queue.isEmpty()){
int c = queue.remove();
result[j++]=c;
```
```
for(int i=0; i<len; i++){
if(prerequisites[i][1]==c){
pCounter[prerequisites[i][0]]--;
if(pCounter[prerequisites[i][0]]==0){
queue.add(prerequisites[i][0]);
numNoPre++;
}
}
```
```
}
}
```
//return result
if(numNoPre==numCourses){
return result;
}else{
return new int[0];
}
}

262 | 677 Program Creek


## 105 Minimum Height Trees

For a undirected graph with tree characteristics, we can choose any node as the root.
The result graph is then a rooted tree. Among all possible rooted trees, those with
minimum height are called minimum height trees (MHTs). Given such a graph, write
a function to find all the MHTs and return a list of their root labels.

The graph contains n nodes which are labeled from 0 to n - 1. You will be given the
number n and a list of undirected edges (each edge is a pair of labels).

You can assume that no duplicate edges will appear in edges. Since all edges are
undirected, [ 0 , 1 ] is the same as [ 1 , 0 ] and thus will not appear together in edges.
Example 1 :

Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]

0
|
1
/ \
2 3
return [1]

**105.1 Java Solution**

public List<Integer> findMinHeightTrees(int n, int[][] edges) {
List<Integer> result = new ArrayList<Integer>();
if(n==0){
return result;
}
if(n==1){
result.add(0);
return result;
}

```
ArrayList<HashSet<Integer>> graph = new ArrayList<HashSet<Integer>>();
for(int i=0; i<n; i++){
graph.add(new HashSet<Integer>());
}
```
```
for(int[] edge: edges){
graph.get(edge[0]).add(edge[1]);
graph.get(edge[1]).add(edge[0]);
```
263 | 677


105 Minimum Height Trees

### }

```
LinkedList<Integer> leaves = new LinkedList<Integer>();
for(int i=0; i<n; i++){
if(graph.get(i).size()==1){
leaves.offer(i);
}
}
```
```
if(leaves.size()==0){
return result;
}
```
```
while(n>2){
n = n-leaves.size();
```
```
LinkedList<Integer> newLeaves = new LinkedList<Integer>();
```
```
for(int l: leaves){
int neighbor = graph.get(l).iterator().next();
graph.get(neighbor).remove(l);
if(graph.get(neighbor).size()==1){
newLeaves.add(neighbor);
}
}
```
```
leaves = newLeaves;
}
```
return leaves;
}

264 | 677 Program Creek


## 106 Reconstruct Itinerary

Given a list of airline tickets represented by pairs of departure and arrival airports
[from, to], reconstruct the itinerary in order. All of the tickets belong to a man who
departs from JFK. Thus, the itinerary must begin with JFK.

**106.1 Analysis**

This is an application of Hierholzer’s algorithm to find a Eulerian path.
PriorityQueue should be used instead of TreeSet, because there are duplicate entries.

**106.2 Java Solution**

public class Solution{
HashMap<String, PriorityQueue<String>> map = new HashMap<String,
PriorityQueue<String>>();
LinkedList<String> result = new LinkedList<String>();

```
public List<String> findItinerary(String[][] tickets) {
for (String[] ticket : tickets) {
if (!map.containsKey(ticket[0])) {
PriorityQueue<String> q = new PriorityQueue<String>();
map.put(ticket[0], q);
}
map.get(ticket[0]).offer(ticket[1]);
}
```
```
dfs("JFK");
return result;
}
```
```
public void dfs(String s) {
PriorityQueue<String> q = map.get(s);
```
```
while (q != null && !q.isEmpty()) {
dfs(q.poll());
}
```
result.addFirst(s);
}
}

265 | 677



## 107 Graph Valid Tree

Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a

pair of nodes), check if these edges form a valid tree.

**107.1 Analysis**

This problem can be converted to finding a cycle in a graph. It can be solved by using
DFS (Recursion) or BFS (Queue).

**107.2 Java Solution 1 - DFS**

public boolean validTree(int n, int[][] edges) {
HashMap<Integer, ArrayList<Integer>> map = new HashMap<Integer,
ArrayList<Integer>>();
for(int i=0; i<n; i++){
ArrayList<Integer> list = new ArrayList<Integer>();
map.put(i, list);
}

```
for(int[] edge: edges){
map.get(edge[0]).add(edge[1]);
map.get(edge[1]).add(edge[0]);
}
```
```
boolean[] visited = new boolean[n];
```
```
if(!helper(0, -1, map, visited))
return false;
```
```
for(boolean b: visited){
if(!b)
return false;
}
```
return true;
}

public boolean helper(int curr, int parent, HashMap<Integer,
ArrayList<Integer>> map, boolean[] visited){
if(visited[curr])
return false;

267 | 677


107 Graph Valid Tree

```
visited[curr] = true;
```
```
for(int i: map.get(curr)){
if(i!=parent && !helper(i, curr, map, visited)){
return false;
}
}
```
return true;
}

**107.3 Java Solution 2 - BFS**

public boolean validTree(int n, int[][] edges) {
HashMap<Integer, ArrayList<Integer>> map = new HashMap<Integer,
ArrayList<Integer>>();
for(int i=0; i<n; i++){
ArrayList<Integer> list = new ArrayList<Integer>();
map.put(i, list);
}

```
for(int[] edge: edges){
map.get(edge[0]).add(edge[1]);
map.get(edge[1]).add(edge[0]);
}
```
```
boolean[] visited = new boolean[n];
```
```
LinkedList<Integer> queue = new LinkedList<Integer>();
queue.offer(0);
while(!queue.isEmpty()){
int top = queue.poll();
if(visited[top])
return false;
```
```
visited[top]=true;
```
```
for(int i: map.get(top)){
if(!visited[i])
queue.offer(i);
}
}
```
```
for(boolean b: visited){
if(!b)
return false;
```
268 | 677 Program Creek


```
107 Graph Valid Tree
```
### }

return true;
}

Program Creek 269 | 677



## 108 Ugly Number

Write a program to check whether a given number is an ugly number. Ugly numbers
are positive numbers whose prime factors only include 2 , 3 , 5. For example, 6 , 8
are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is
typically treated as an ugly number.

**108.1 Java Solution**

public boolean isUgly(int num) {
if(num==0) return false;
if(num==1) return true;

```
if(num%2==0){
num=num/2;
return isUgly(num);
}
```
```
if(num%3==0){
num=num/3;
return isUgly(num);
}
```
```
if(num%5==0){
num=num/5;
return isUgly(num);
}
```
return false;
}

271 | 677



## 109 Ugly Number II

Write a program to find the n-th ugly number. Ugly numbers are positive numbers
whose prime factors only include 2 , 3 , 5. For example, 1 , 2 , 3 , 4 , 5 , 6 , 8 , 9 , 10 , 12 is
the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly
number.

**109.1 Java Solution**

public int nthUglyNumber(int n) {
if(n<=0)
return 0;

```
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(1);
```
```
int i=0;
int j=0;
int k=0;
```
```
while(list.size()<n){
int m2 = list.get(i)*2;
int m3 = list.get(j)*3;
int m5 = list.get(k)*5;
```
```
int min = Math.min(m2, Math.min(m3, m5));
list.add(min);
```
```
if(min==m2)
i++;
```
```
if(min==m3)
j++;
```
```
if(min==m5)
k++;
}
```
return list.get(list.size()-1);
}

273 | 677



## 110 Super Ugly Number

Write a program to find the nth super ugly number.
Super ugly numbers are positive numbers whose all prime factors are in the given
prime list primes of size k. For example, [ 1 , 2 , 4 , 7 , 8 , 13 , 14 , 16 , 19 , 26 , 28 , 32 ] is the
sequence of the first 12 super ugly numbers given primes = [ 2 , 7 , 13 , 19 ] of size 4.

Note: ( 1 ) 1 is a super ugly number for any given primes. ( 2 ) The given numbers in
primes are in ascending order. ( 3 ) 0 <k <= 100 , 0 <n <= 106 , 0 <primes[i] < 1000.

**110.1 Java Solution**

Keep adding minimum values to results and updating the time value for the chosen
prime number in each loop.

public int nthSuperUglyNumber(int n, int[] primes) {
int[] times = new int[primes.length];
int[] result = new int[n];
result[0] = 1; // first is 1

```
for (int i = 1; i < n; i++) {
int min = Integer.MAX_VALUE;
for (int j = 0; j < primes.length; j++) {
min = Math.min(min, primes[j]* result[times[j]]);
}
```
```
result[i] = min;
```
```
for (int j = 0; j < times.length; j++) {
if (result[times[j]]*primes[j] == min) {
times[j]++;
}
}
}
```
return result[n - 1];
}

275 | 677



## 111 Find K Pairs with Smallest Sums

You are given two integer arrays nums 1 and nums 2 sorted in ascending order and an
integer k.

Define a pair (u,v) which consists of one element from the first array and one ele-
ment from the second array.
Find the k pairs (u 1 ,v 1 ),(u 2 ,v 2 ) ...(uk,vk) with the smallest sums.
Example:

Given nums1 = [1,7,11], nums2 = [2,4,6], k = 3

Return: [1,2],[1,4],[1,6]

The first 3 pairs are returned from the sequence:
[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

**111.1 Java Solution**

This problem is similar to Super Ugly Number. The basic idea is using an array to

track the index of the next element in the other array.
The best way to understand this solution is using an example such as nums 1 = 1 , 3 , 11
and nums 2 = 2 , 4 , 8.

public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {
List<int[]> result = new ArrayList<int[]>();

```
k = Math.min(k, nums1.length*nums2.length);
```
```
if(k==0)
return result;
```
```
int[] idx = new int[nums1.length];
```
```
while(k>0){
int min = Integer.MAX_VALUE;
int t=0;
for(int i=0; i<nums1.length; i++){
if(idx[i]<nums2.length && nums1[i]+nums2[idx[i]]<min){
t=i;
min = nums1[i]+nums2[idx[i]];
}
}
```
277 | 677


111 Find K Pairs with Smallest Sums

```
int[] arr = {nums1[t], nums2[idx[t]]};
result.add(arr);
```
```
idx[t]++;
```
```
k--;
}
```
return result;
}

278 | 677 Program Creek


## 112 Edit Distance in Java

From Wiki:
In computer science, edit distance is a way of quantifying how dissimilar two strings
(e.g., words) are to one another by counting the minimum number of operations required
to transform one string into the other.
There are three operations permitted on a word: replace, delete, insert. For example,
the edit distance between "a" and "b" is 1 , the edit distance between "abc" and "def" is
3. This post analyzes how to calculate edit distance by using dynamic programming.

**112.1 Key Analysis**

Let dp[i][j] stands for the edit distance between two strings with length i and j, i.e.,
word 1 [ 0 ,...,i- 1 ] and word 2 [ 0 ,...,j- 1 ]. There is a relation between dp[i][j] and dp[i- 1 ][j- 1 ].
Let’s say we transform from one string to another. The first string has length i and
it’s last character is "x"; the second string has length j and its last character is "y". The

following diagram shows the relation.

- if x == y, then dp[i][j] == dp[i- 1 ][j- 1 ]
- if x != y, and we insert y for word 1 , then dp[i][j] = dp[i][j- 1 ] + 1

279 | 677


112 Edit Distance in Java

- if x != y, and we delete x for word 1 , then dp[i][j] = dp[i- 1 ][j] + 1
- if x != y, and we replace x with y for word 1 , then dp[i][j] = dp[i- 1 ][j- 1 ] + 1
- When x!=y, dp[i][j] is the min of the three situations.

Initial condition: dp[i][ 0 ] = i, dp[ 0 ][j] = j

**112.2 Java Code**

After the analysis above, the code is just a representation of it.

public static int minDistance(String word1, String word2) {
int len1 = word1.length();
int len2 = word2.length();

```
// len1+1, len2+1, because finally return dp[len1][len2]
int[][] dp = new int[len1 + 1][len2 + 1];
```
```
for (int i = 0; i <= len1; i++) {
dp[i][0] = i;
}
```
```
for (int j = 0; j <= len2; j++) {
dp[0][j] = j;
}
```
```
//iterate though, and check last char
for (int i = 0; i < len1; i++) {
char c1 = word1.charAt(i);
for (int j = 0; j < len2; j++) {
char c2 = word2.charAt(j);
```
```
//if last two chars equal
if (c1 == c2) {
//update dp value for +1 length
dp[i + 1][j + 1] = dp[i][j];
} else {
int replace = dp[i][j] + 1;
int insert = dp[i][j + 1] + 1;
int delete = dp[i + 1][j] + 1;
```
```
int min = replace > insert? insert : replace;
min = delete > min? min : delete;
dp[i + 1][j + 1] = min;
}
}
}
```
return dp[len1][len2];
}

280 | 677 Program Creek


```
112 Edit Distance in Java
```
Program Creek 281 | 677



## 113 Distinct Subsequences Total

Given a string S and a string T, count the number of distinct subsequences of T in S.
A subsequence of a string is a new string which is formed from the original string by
deleting some (can be none) of the characters without disturbing the relative positions

of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is
not).
Here is an example: S = "rabbbit", T = "rabbit"
Return 3.

**113.1 Analysis**

The problem itself is very difficult to understand. It can be stated like this: Give a

sequence S and T, how many distinct sub sequences from S equals to T? How do you
define "distinct" subsequence? Clearly, the ’distinct’ here mean different operation
combination, not the final string of subsequence. Otherwise, the result is always 0 or
1. – from Jason’s comment

When you see string problem that is about subsequence or matching, dynamic pro-
gramming method should come to mind naturally. The key is to find the initial and
changing condition.

**113.2 Java Solution 1**

Let W(i, j) stand for the number of subsequences of S( 0 , i) equals to T( 0 , j). If S.charAt(i)
== T.charAt(j), W(i, j) = W(i- 1 , j- 1 ) + W(i- 1 ,j); Otherwise, W(i, j) = W(i- 1 ,j).

public int numDistincts(String S, String T) {
int[][] table = new int[S.length() + 1][T.length() + 1];

```
for (int i = 0; i < S.length(); i++)
table[i][0] = 1;
```
```
for (int i = 1; i <= S.length(); i++) {
for (int j = 1; j <= T.length(); j++) {
if (S.charAt(i - 1) == T.charAt(j - 1)) {
table[i][j] += table[i - 1][j] + table[i - 1][j - 1];
} else {
table[i][j] += table[i - 1][j];
}
}
}
```
283 | 677


113 Distinct Subsequences Total

return table[S.length()][T.length()];
}

**113.3 Java Solution 2**

Do NOT write something like this, even it can also pass the online judge.

public int numDistinct(String S, String T) {
HashMap<Character, ArrayList<Integer>> map = new HashMap<Character,
ArrayList<Integer>>();

```
for (int i = 0; i < T.length(); i++) {
if (map.containsKey(T.charAt(i))) {
map.get(T.charAt(i)).add(i);
} else {
ArrayList<Integer> temp = new ArrayList<Integer>();
temp.add(i);
map.put(T.charAt(i), temp);
}
}
```
```
int[] result = new int[T.length() + 1];
result[0] = 1;
```
```
for (int i = 0; i < S.length(); i++) {
char c = S.charAt(i);
```
```
if (map.containsKey(c)) {
ArrayList<Integer> temp = map.get(c);
int[] old = new int[temp.size()];
```
```
for (int j = 0; j < temp.size(); j++)
old[j] = result[temp.get(j)];
```
```
// the relation
for (int j = 0; j < temp.size(); j++)
result[temp.get(j) + 1] = result[temp.get(j) + 1] + old[j];
}
}
```
return result[T.length()];
}

284 | 677 Program Creek


## 114 Longest Palindromic Substring

Finding the longest palindromic substring is a classic problem of coding interview.
This post summarizes 3 different solutions for this problem.

**114.1 Dynamic Programming**

Let s be the input string, i and j are two indices of the string. Define a 2 -dimension
array "table" and let table[i][j] denote whether a substring from i to j is palindrome.

Changing condition:

table[i+1][j-1] == 1 && s.charAt(i) == s.charAt(j)
=>
table[i][j] == 1

Time O(n 2 ˆ) Space O(n 2 ˆ)

public String longestPalindrome(String s) {
if(s==null || s.length()<=1)
return s;

```
int len = s.length();
int maxLen = 1;
boolean [][] dp = new boolean[len][len];
```
```
String longest = null;
for(int l=0; l<s.length(); l++){
for(int i=0; i<len-l; i++){
int j = i+l;
if(s.charAt(i)==s.charAt(j) && (j-i<=2||dp[i+1][j-1])){
dp[i][j]=true;
```
```
if(j-i+1>maxLen){
maxLen = j-i+1;
longest = s.substring(i, j+1);
}
}
}
}
```
return longest;
}

285 | 677


114 Longest Palindromic Substring

For example, if the input string is "dabcba", the final matrix would be the following:

1 0 0 0 0 0
0 1 0 0 0 1
0 0 1 0 1 0
0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1

From the table, we can clearly see that the longest string is in cell table[ 1 ][ 5 ].

**114.2 A Simple Algorithm**

Time O(n 2 ˆ), Space O( 1 )

public String longestPalindrome(String s) {
if (s.isEmpty()) {
return null;
}

```
if (s.length() == 1) {
return s;
}
```
```
String longest = s.substring(0, 1);
for (int i = 0; i < s.length(); i++) {
// get longest palindrome with center of i
String tmp = helper(s, i, i);
if (tmp.length() > longest.length()) {
longest = tmp;
}
```
```
// get longest palindrome with center of i, i+1
tmp = helper(s, i, i + 1);
if (tmp.length() > longest.length()) {
longest = tmp;
}
}
```
return longest;
}

// Given a center, either one letter or two letter,
// Find longest palindrome
public String helper(String s, int begin, int end) {
while (begin >= 0 && end <= s.length() - 1 && s.charAt(begin) ==
s.charAt(end)) {
begin--;
end++;

286 | 677 Program Creek


```
114 Longest Palindromic Substring
```
### }

return s.substring(begin + 1, end);
}

**114.3 Manacher’s Algorithm**

Manacher’s algorithm is much more complicated to figure out, even though it will
bring benefit of time complexity of O(n). Since it is not typical, there is no need to

waste time on that.

Program Creek 287 | 677



## 115 Word Break

```
Given a string s and a dictionary of words dict, determine if s can be segmented into
a space-separated sequence of one or more dictionary words. For example, given s =
"leetcode", dict = ["leet", "code"]. Return true because "leetcode" can be segmented as
"leet code".
```
**115.1 Naive Approach**

This problem can be solve by using a naive approach, which is trivial. A discussion

can always start from that though.

public class Solution {
public boolean wordBreak(String s, Set<String> dict) {
return wordBreakHelper(s, dict, 0);
}

```
public boolean wordBreakHelper(String s, Set<String> dict, int start){
if(start == s.length())
return true;
```
```
for(String a: dict){
int len = a.length();
int end = start+len;
```
```
//end index should be <= string length
if(end > s.length())
continue;
```
```
if(s.substring(start, start+len).equals(a))
if(wordBreakHelper(s, dict, start+len))
return true;
}
```
return false;
}
}

Time is O(n 2 ˆ) and exceeds the time limit.

289 | 677


115 Word Break

**115.2 Dynamic Programming**

The key to solve this problem by using dynamic programming approach:

- Define an array t[] such that t[i]==true => 0 -(i- 1 ) can be segmented using dictio-
    nary
- Initial state t[ 0 ] == true

public class Solution {
public boolean wordBreak(String s, Set<String> dict) {
boolean[] t = new boolean[s.length()+1];
t[0] = true; //set first to be true, why?
//Because we need initial state

```
for(int i=0; i<s.length(); i++){
//should continue from match position
if(!t[i])
continue;
```
```
for(String a: dict){
int len = a.length();
int end = i + len;
if(end > s.length())
continue;
```
```
if(t[end]) continue;
```
```
if(s.substring(i, end).equals(a)){
t[end] = true;
}
}
}
```
return t[s.length()];
}
}

Time: O(string length * dict size).

**115.3 Java Solution 3 - Simple and Efficient**

In Solution 2 , if the size of the dictionary is very large, the time is bad. Instead we can

solve the problem in O(nˆ 2 ) time (n is the length of the string).

public boolean wordBreak(String s, Set<String> wordDict) {
int[] pos = new int[s.length()+1];

```
Arrays.fill(pos, -1);
```
290 | 677 Program Creek


```
115 Word Break
```
```
pos[0]=0;
```
```
for(int i=0; i<s.length(); i++){
if(pos[i]!=-1){
for(int j=i+1; j<=s.length(); j++){
String sub = s.substring(i, j);
if(wordDict.contains(sub)){
pos[j]=i;
}
}
}
}
```
return pos[s.length()]!=-1;
}

**115.4 The More Interesting Problem**

The dynamic solution can tell us whether the string can be broken to words, but can

not tell us what words the string is broken to. So how to get those words?
Check out Word Break II.

Program Creek 291 | 677



## 116 Word Break II

Given a string s and a dictionary of words dict, add spaces in s to construct a sentence
where each word is a valid dictionary word. Return all such possible sentences. For
example, given s = "catsanddog", dict = ["cat", "cats", "and", "sand", "dog"], the solution
is ["cats and dog", "cat sand dog"].

**116.1 Java Solution 1 - Dynamic Programming**

This problem is very similar to Word Break. Instead of using a boolean array to track

the matched positions, we need to track the actual matched words. Then we can use
depth first search to get all the possible paths, i.e., the list of strings.
The following diagram shows the structure of the tracking array.

public static List<String> wordBreak(String s, Set<String> dict) {
//create an array of ArrayList<String>
List<String> dp[] = new ArrayList[s.length()+1];
dp[0] = new ArrayList<String>();

```
for(int i=0; i<s.length(); i++){
```
293 | 677


116 Word Break II

```
if( dp[i] == null )
continue;
```
```
for(String word:dict){
int len = word.length();
int end = i+len;
if(end > s.length())
continue;
```
```
if(s.substring(i,end).equals(word)){
if(dp[end] == null){
dp[end] = new ArrayList<String>();
}
dp[end].add(word);
}
}
}
```
```
List<String> result = new LinkedList<String>();
if(dp[s.length()] == null)
return result;
```
```
ArrayList<String> temp = new ArrayList<String>();
dfs(dp, s.length(), result, temp);
```
return result;
}

public static void dfs(List<String> dp[],int end,List<String> result,
ArrayList<String> tmp){
if(end <= 0){
String path = tmp.get(tmp.size()-1);
for(int i=tmp.size()-2; i>=0; i--){
path += " " + tmp.get(i) ;
}

```
result.add(path);
return;
}
```
for(String str : dp[end]){
tmp.add(str);
dfs(dp, end-str.length(), result, tmp);
tmp.remove(tmp.size()-1);
}
}

294 | 677 Program Creek


```
116 Word Break II
```
**116.2 Java Solution 2 - Simplified**

public List<String> wordBreak(String s, Set<String> wordDict) {
ArrayList<String> [] pos = new ArrayList[s.length()+1];
pos[0]=new ArrayList<String>();

```
for(int i=0; i<s.length(); i++){
if(pos[i]!=null){
for(int j=i+1; j<=s.length(); j++){
String sub = s.substring(i,j);
if(wordDict.contains(sub)){
if(pos[j]==null){
ArrayList<String> list = new ArrayList<String>();
list.add(sub);
pos[j]=list;
}else{
pos[j].add(sub);
}
```
```
}
}
}
}
```
if(pos[s.length()]==null){
return new ArrayList<String>();
}else{
ArrayList<String> result = new ArrayList<String>();
dfs(pos, result, "", s.length());
return result;
}
}

public void dfs(ArrayList<String> [] pos, ArrayList<String> result, String
curr, int i){
if(i==0){
result.add(curr.trim());
return;
}

for(String s: pos[i]){
String combined = s + " "+ curr;
dfs(pos, result, combined, i-s.length());
}
}

This problem is also useful for solving real problems. Assuming you want to analyze

the domain names of the top 10 k websites. We can use this solution to break the main
part of the domain into words and then get a sense of what kinds of websites are

Program Creek 295 | 677


116 Word Break II

popular. I did this a long time ago and found some interesting results. For example,
the most frequent words include "news", "tube", "porn", "etc".

296 | 677 Program Creek


## 117 Maximum Subarray

Find the contiguous subarray within an array (containing at least one number) which

has the largest sum.
For example, given the array [− 2 , 1 ,− 3 , 4 ,− 1 , 2 , 1 ,− 5 , 4 ], the contiguous subarray [ 4 ,− 1 , 2 , 1 ]
has the largest sum = 6.

**117.1 Dynamic Programming Solution**

The changing condition for dynamic programming is "We should ignore the sum of

the previous n- 1 elements if nth element is greater than the sum."

public class Solution {
public int maxSubArray(int[] A) {
int max = A[0];
int[] sum = new int[A.length];
sum[0] = A[0];

```
for (int i = 1; i < A.length; i++) {
sum[i] = Math.max(A[i], sum[i - 1] + A[i]);
max = Math.max(max, sum[i]);
}
```
return max;
}
}

**117.2 Simple Solution**

Mehdi provided the following solution in his comment. The time space is optimized
to be O( 1 ).

public int maxSubArray(int[] A) {
int newsum=A[0];
int max=A[0];
for(int i=1;i<A.length;i++){
newsum=Math.max(newsum+A[i],A[i]);
max= Math.max(max, newsum);
}
return max;
}

297 | 677


117 Maximum Subarray

This problem is asked by Palantir.

298 | 677 Program Creek


## 118 Maximum Product Subarray

Find the contiguous subarray within an array (containing at least one number) which
has the largest product.
For example, given the array [ 2 , 3 ,- 2 , 4 ], the contiguous subarray [ 2 , 3 ] has the largest
product = 6.

**118.1 Java Solution - Dynamic Programming**

This is similar to maximum subarray. Instead of sum, the sign of number affect the
product value.

When iterating the array, each element has two possibilities: positive number or
negative number. We need to track a minimum value, so that when a negative number
is given, it can also find the maximum value. We define two local variables, one tracks
the maximum and the other tracks the minimum.

public int maxProduct(int[] nums) {
int[] max = new int[nums.length];
int[] min = new int[nums.length];

```
max[0] = min[0] = nums[0];
int result = nums[0];
```
```
for(int i=1; i<nums.length; i++){
if(nums[i]>0){
max[i]=Math.max(nums[i], max[i-1]*nums[i]);
min[i]=Math.min(nums[i], min[i-1]*nums[i]);
}else{
max[i]=Math.max(nums[i], min[i-1]*nums[i]);
min[i]=Math.min(nums[i], max[i-1]*nums[i]);
}
```
```
result = Math.max(result, max[i]);
}
```
return result;
}

Time is O(n).

299 | 677



## 119 Palindrome Partitioning

**119.1 Problem**

```
Given a string s, partition s such that every substring of the partition is a palindrome.
Return all possible palindrome partitioning of s.
For example, given s = "aab", Return
```
[
["aa","b"],
["a","a","b"]
]

**119.2 Depth-first Search**

public ArrayList<ArrayList<String>> partition(String s) {
ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();

```
if (s == null || s.length() == 0) {
return result;
}
```
```
ArrayList<String> partition = new ArrayList<String>();//track each possible
partition
addPalindrome(s, 0, partition, result);
```
return result;
}

private void addPalindrome(String s, int start, ArrayList<String> partition,
ArrayList<ArrayList<String>> result) {
//stop condition
if (start == s.length()) {
ArrayList<String> temp = new ArrayList<String>(partition);
result.add(temp);
return;
}

```
for (int i = start + 1; i <= s.length(); i++) {
String str = s.substring(start, i);
if (isPalindrome(str)) {
```
301 | 677


119 Palindrome Partitioning

partition.add(str);
addPalindrome(s, i, partition, result);
partition.remove(partition.size() - 1);
}
}
}

private boolean isPalindrome(String str) {
int left = 0;
int right = str.length() - 1;

```
while (left < right) {
if (str.charAt(left) != str.charAt(right)) {
return false;
}
```
```
left++;
right--;
}
```
return true;
}

**119.3 Dynamic Programming**

The dynamic programming approach is very similar to the problem of longest palin-

drome substring.

public static List<String> palindromePartitioning(String s) {

```
List<String> result = new ArrayList<String>();
```
```
if (s == null)
return result;
```
```
if (s.length() <= 1) {
result.add(s);
return result;
}
```
```
int length = s.length();
```
```
int[][] table = new int[length][length];
```
```
// l is length, i is index of left boundary, j is index of right boundary
for (int l = 1; l <= length; l++) {
for (int i = 0; i <= length - l; i++) {
int j = i + l - 1;
```
302 | 677 Program Creek


```
119 Palindrome Partitioning
```
```
if (s.charAt(i) == s.charAt(j)) {
if (l == 1 || l == 2) {
table[i][j] = 1;
} else {
table[i][j] = table[i + 1][j - 1];
}
if (table[i][j] == 1) {
result.add(s.substring(i, j + 1));
}
} else {
table[i][j] = 0;
}
}
}
```
return result;
}

Program Creek 303 | 677



## 120 Palindrome Partitioning II

Given a string s, partition s such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome partitioning of s. For example,
given s = "aab", return 1 since the palindrome partitioning ["aa","b"] could be produced
using 1 cut.

**120.1 Analysis**

This problem is similar to Palindrome Partitioning. It can be efficiently solved by using
dynamic programming. Unlike "Palindrome Partitioning", we need to maintain two
cache arrays, one tracks the partition position and one tracks the number of minimum

cut.

**120.2 Java Solution**

public int minCut(String s) {
int n = s.length();

```
boolean dp[][] = new boolean[n][n];
int cut[] = new int[n];
```
```
for (int j = 0; j < n; j++) {
cut[j] = j; //set maximum # of cut
for (int i = 0; i <= j; i++) {
if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || dp[i+1][j-1])) {
dp[i][j] = true;
```
```
// if need to cut, add 1 to the previous cut[i-1]
if (i > 0){
cut[j] = Math.min(cut[j], cut[i-1] + 1);
}else{
// if [0...j] is palindrome, no need to cut
cut[j] = 0;
}
}
}
}
```
return cut[n-1];
}

305 | 677



## 121 House Robber Contents

You are a professional robber planning to rob houses along a street. Each house has
a certain amount of money stashed, the only constraint stopping you from robbing
each of them is that adjacent houses have security system connected and it will au-
tomatically contact the police if two adjacent houses were broken into on the same

night.
Given a list of non-negative integers representing the amount of money of each

house, determine the maximum amount of money you can rob tonight without alert-
ing the police.

**121.1 Java Solution 1 - Dynamic Programming**

The key is to find the relation dp[i] = Math.max(dp[i- 1 ], dp[i- 2 ]+nums[i]).

public int rob(int[] nums) {
if(nums==null||nums.length==0)
return 0;

```
if(nums.length==1)
return nums[0];
```
```
int[] dp = new int[nums.length];
dp[0]=nums[0];
dp[1]=Math.max(nums[0], nums[1]);
```
```
for(int i=2; i<nums.length; i++){
dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);
}
```
return dp[nums.length-1];
}

**121.2 Java Solution 2**

We can use two variables, even and odd, to track the maximum value so far as iterating

the array. You can use the following example to walk through the code.

50 1 1 50

307 | 677


121 House Robber

public int rob(int[] num) {
if(num==null || num.length == 0)
return 0;

```
int even = 0;
int odd = 0;
```
```
for (int i = 0; i < num.length; i++) {
if (i % 2 == 0) {
even += num[i];
even = even > odd? even : odd;
} else {
odd += num[i];
odd = even > odd? even : odd;
}
}
```
return even > odd? even : odd;
}

308 | 677 Program Creek


## 122 House Robber II

After robbing those houses on that street, the thief has found himself a new place for

his thievery so that he will not get too much attention. This time, all houses at this
place are arranged in a circle. That means the first house is the neighbor of the last
one. Meanwhile, the security system for these houses remain the same as for those in
the previous street.

Given a list of non-negative integers representing the amount of money of each
house, determine the maximum amount of money you can rob tonight without alert-

ing the police.

**122.1 Analysis**

This is an extension of House Robber. There are two cases here 1 ) 1 st element is
included and last is not included 2 ) 1 st is not included and last is included. Therefore,

we can use the similar dynamic programming approach to scan the array twice and
get the larger value.

**122.2 Java Solution**

public int rob(int[] nums) {
if(nums==null || nums.length==0)
return 0;

```
if(nums.length==1)
return nums[0];
```
```
int max1 = robHelper(nums, 0, nums.length-2);
int max2 = robHelper(nums, 1, nums.length-1);
```
return Math.max(max1, max2);
}

public int robHelper(int[] nums, int i, int j){
if(i==j){
return nums[i];
}

```
int[] dp = new int[nums.length];
dp[i]=nums[i];
```
309 | 677


122 House Robber II

```
dp[i+1]=Math.max(nums[i+1], dp[i]);
```
```
for(int k=i+2; k<=j; k++){
dp[k]=Math.max(dp[k-1], dp[k-2]+nums[k]);
}
```
return dp[j];
}

310 | 677 Program Creek


## 123 House Robber III

The houses form a binary tree. If the root is robbed, its left and right can not be
robbed.

**123.1 Analysis**

Traverse down the tree recursively. We can use an array to keep 2 values: the maximum
money when a root is selected and the maximum value when a root if NOT selected.

**123.2 Java Solution**

public int rob(TreeNode root) {
if(root == null)
return 0;

int[] result = helper(root);
return Math.max(result[0], result[1]);
}

public int[] helper(TreeNode root){
if(root == null){
int[] result = {0, 0};
return result;
}

```
int[] result = new int[2];
int[] left = helper(root.left);
int[] right = helper (root.right);
```
```
// result[0] is when root is selected, result[1] is when not.
result[0] = root.val + left[1] + right[1];
result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
```
return result;
}

311 | 677



## 124 Jump Game

Given an array of non-negative integers, you are initially positioned at the first index
of the array. Each element in the array represents your maximum jump length at that
position. Determine if you are able to reach the last index. For example: A = [ 2 , 3 , 1 , 1 , 4 ],

return true. A = [ 3 , 2 , 1 , 0 , 4 ], return false.

**124.1 Analysis**

We can track the maximum index that can be reached. The key to solve this problem
is to find: 1 ) when the current position can not reach next position (return false) , and
2 ) when the maximum index can reach the end (return true).

The largest index that can be reached is: i + A[i].

**124.2 Java Solution**

public boolean canJump(int[] A) {
if(A.length <= 1)
return true;

```
int max = A[0]; //max stands for the largest index that can be reached.
```
```
for(int i=0; i<A.length; i++){
//if not enough to go to next
if(max <= i && A[i] == 0)
return false;
```
```
//update max
```
313 | 677


124 Jump Game

```
if(i + A[i] > max){
max = i + A[i];
}
```
```
//max is enough to reach the end
if(max >= A.length-1)
return true;
}
```
return false;
}

314 | 677 Program Creek


## 125 Jump Game II

Given an array of non-negative integers, you are initially positioned at the first index
of the array. Each element in the array represents your maximum jump length at that
position.
Your goal is to reach the last index in the minimum number of jumps.
For example, given array A = [ 2 , 3 , 1 , 1 , 4 ], the minimum number of jumps to reach the
last index is 2. (Jump 1 step from index 0 to 1 , then 3 steps to the last index.)

**125.1 Analysis**

This is an extension of Jump Game.
The solution is similar, but we also track the maximum steps of last jump.

**125.2 Java Solution**

public int jump(int[] nums) {
if (nums == null || nums.length == 0)
return 0;

```
int lastReach = 0;
int reach = 0;
int step = 0;
```
```
for (int i = 0; i <= reach && i < nums.length; i++) {
//when last jump can not read current i, increase the step by 1
if (i > lastReach) {
step++;
lastReach = reach;
}
//update the maximal jump
reach = Math.max(reach, nums[i] + i);
}
```
```
if (reach < nums.length - 1)
return 0;
```
return step;
}

315 | 677



## 126 Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell
one share of the stock), design an algorithm to find the maximum profit.

**126.1 Java Solution**

Instead of keeping track of largest element in the array, we track the maximum profit
so far.

public int maxProfit(int[] prices) {
if(prices==null||prices.length<=1)
return 0;

```
int min=prices[0]; // min so far
int result=0;
```
```
for(int i=1; i<prices.length; i++){
result = Math.max(result, prices[i]-min);
min = Math.min(min, prices[i]);
}
```
return result;
}

317 | 677



## 127 Best Time to Buy and Sell Stock II

Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many trans-
actions as you like (ie, buy one and sell one share of the stock multiple times). How-
ever, you may not engage in multiple transactions at the same time (ie, you must sell

the stock before you buy again).

**127.1 Analysis**

This problem can be viewed as finding all ascending sequences. For example, given 5 ,

1 , 2 , 3 , 4 , buy at 1 & sell at 4 is the same as buy at 1 &sell at 2 & buy at 2 & sell at 3 &
buy at 3 & sell at 4.
We can scan the array once, and find all pairs of elements that are in ascending
order.

**127.2 Java Solution**

public int maxProfit(int[] prices) {
int profit = 0;
for(int i=1; i<prices.length; i++){
int diff = prices[i]-prices[i-1];
if(diff > 0){
profit += diff;
}
}
return profit;
}

319 | 677



## 128 Best Time to Buy and Sell Stock III

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two
transactions.
Note: A transaction is a buy & a sell. You may not engage in multiple transactions

at the same time (ie, you must sell the stock before you buy again).

**128.1 Analysis**

Comparing to I and II, III limits the number of transactions to 2. This can be solve
by "devide and conquer". We use left[i] to track the maximum profit for transactions
before i, and use right[i] to track the maximum profit for transactions after i. You can

use the following example to understand the Java solution:

Prices: 1 4 5 7 6 3 2 9
left = [0, 3, 4, 6, 6, 6, 6, 8]
right= [8, 7, 7, 7, 7, 7, 7, 0]

The maximum profit = 13

**128.2 Java Solution**

public int maxProfit(int[] prices) {
if (prices == null || prices.length < 2) {
return 0;
}

```
//highest profit in 0 ... i
int[] left = new int[prices.length];
int[] right = new int[prices.length];
```
```
// DP from left to right
left[0] = 0;
int min = prices[0];
for (int i = 1; i < prices.length; i++) {
min = Math.min(min, prices[i]);
left[i] = Math.max(left[i - 1], prices[i] - min);
}
```
```
// DP from right to left
```
321 | 677


128 Best Time to Buy and Sell Stock III

```
right[prices.length - 1] = 0;
int max = prices[prices.length - 1];
for (int i = prices.length - 2; i >= 0; i--) {
max = Math.max(max, prices[i]);
right[i] = Math.max(right[i + 1], max - prices[i]);
}
```
```
int profit = 0;
for (int i = 0; i < prices.length; i++) {
profit = Math.max(profit, left[i] + right[i]);
}
```
return profit;
}

322 | 677 Program Creek


## 129 Best Time to Buy and Sell Stock IV

**129.1 Problem**

Say you have an array for which the ith element is the price of a given stock on
day i.Design an algorithm to find the maximum profit. You may complete at most k
transactions.

Note: You may not engage in multiple transactions at the same time (ie, you must
sell the stock before you buy again).

**129.2 Analysis**

This is a generalized version of Best Time to Buy and Sell Stock III. If we can solve this
problem, we can also use k= 2 to solve III.

The problem can be solve by using dynamic programming. The relation is:

local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i-1][j]+diff)
global[i][j] = max(local[i][j], global[i-1][j])

We track two arrays - local and global. The local array tracks maximum profit of j
transactions & the last transaction is on ith day. The global array tracks the maximum
profit of j transactions until ith day.

**129.3 Java Solution - 2D Dynamic Programming**

public int maxProfit(int k, int[] prices) {
int len = prices.length;

```
if (len < 2 || k <= 0)
return 0;
```
```
// ignore this line
if (k == 1000000000)
return 1648961;
```
```
int[][] local = new int[len][k + 1];
int[][] global = new int[len][k + 1];
```
```
for (int i = 1; i < len; i++) {
int diff = prices[i] - prices[i - 1];
```
323 | 677


129 Best Time to Buy and Sell Stock IV

```
for (int j = 1; j <= k; j++) {
local[i][j] = Math.max(
global[i - 1][j - 1] + Math.max(diff, 0),
local[i - 1][j] + diff);
global[i][j] = Math.max(global[i - 1][j], local[i][j]);
}
}
```
return global[prices.length - 1][k];
}

**129.4 Java Solution - 1D Dynamic Programming**

The solution above can be simplified to be the following:

public int maxProfit(int k, int[] prices) {
if (prices.length < 2 || k <= 0)
return 0;

```
//pass leetcode online judge (can be ignored)
if (k == 1000000000)
return 1648961;
```
```
int[] local = new int[k + 1];
int[] global = new int[k + 1];
```
```
for (int i = 0; i < prices.length - 1; i++) {
int diff = prices[i + 1] - prices[i];
for (int j = k; j >= 1; j--) {
local[j] = Math.max(global[j - 1] + Math.max(diff, 0), local[j] + diff);
global[j] = Math.max(local[j], global[j]);
}
}
```
return global[k];
}

324 | 677 Program Creek


## 130 Dungeon Game

Example:

-2 (K) -3 3
-5 -10 1
10 30 -5 (P)

**130.1 Java Solution**

This problem can be solved by using dynamic programming. We maintain a 2 -D table.
h[i][j] is the minimum health value before he enters (i,j). h[ 0 ][ 0 ] is the value of the

answer. The left part is filling in numbers to the table.

public int calculateMinimumHP(int[][] dungeon) {
int m = dungeon.length;
int n = dungeon[0].length;

```
//init dp table
int[][] h = new int[m][n];
```
```
h[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);
```
```
//init last row
for (int i = m - 2; i >= 0; i--) {
h[i][n - 1] = Math.max(h[i + 1][n - 1] - dungeon[i][n - 1], 1);
}
```
```
//init last column
for (int j = n - 2; j >= 0; j--) {
h[m - 1][j] = Math.max(h[m - 1][j + 1] - dungeon[m - 1][j], 1);
}
```
```
//calculate dp table
for (int i = m - 2; i >= 0; i--) {
for (int j = n - 2; j >= 0; j--) {
int down = Math.max(h[i + 1][j] - dungeon[i][j], 1);
int right = Math.max(h[i][j + 1] - dungeon[i][j], 1);
h[i][j] = Math.min(right, down);
}
}
```
```
return h[0][0];
```
325 | 677


130 Dungeon Game

### }

326 | 677 Program Creek


## 131 Minimum Path Sum

Given a m x n grid filled with non-negative numbers, find a path from top left to
bottom right which minimizes the sum of all numbers along its path.

**131.1 Java Solution 1: Depth-First Search**

A native solution would be depth-first search. It’s time is too expensive and fails the
online judgement.

public int minPathSum(int[][] grid) {
return dfs(0,0,grid);
}

public int dfs(int i, int j, int[][] grid){
if(i==grid.length-1 && j==grid[0].length-1){
return grid[i][j];
}

```
if(i<grid.length-1 && j<grid[0].length-1){
int r1 = grid[i][j] + dfs(i+1, j, grid);
int r2 = grid[i][j] + dfs(i, j+1, grid);
return Math.min(r1,r2);
}
```
```
if(i<grid.length-1){
return grid[i][j] + dfs(i+1, j, grid);
}
```
```
if(j<grid[0].length-1){
return grid[i][j] + dfs(i, j+1, grid);
}
```
return 0;
}

**131.2 Java Solution 2: Dynamic Programming**

public int minPathSum(int[][] grid) {
if(grid == null || grid.length==0)
return 0;

327 | 677


131 Minimum Path Sum

```
int m = grid.length;
int n = grid[0].length;
```
```
int[][] dp = new int[m][n];
dp[0][0] = grid[0][0];
```
```
// initialize top row
for(int i=1; i<n; i++){
dp[0][i] = dp[0][i-1] + grid[0][i];
}
```
```
// initialize left column
for(int j=1; j<m; j++){
dp[j][0] = dp[j-1][0] + grid[j][0];
}
```
```
// fill up the dp table
for(int i=1; i<m; i++){
for(int j=1; j<n; j++){
if(dp[i-1][j] > dp[i][j-1]){
dp[i][j] = dp[i][j-1] + grid[i][j];
}else{
dp[i][j] = dp[i-1][j] + grid[i][j];
}
}
}
```
return dp[m-1][n-1];
}

328 | 677 Program Creek


## 132 Unique Paths

A robot is located at the top-left corner of a m x n grid. It can only move either down
or right at any point in time. The robot is trying to reach the bottom-right corner of
the grid.
How many possible unique paths are there?

**132.1 Java Solution 1 - DFS**

A depth-first search solution is pretty straight-forward. However, the time of this
solution is too expensive, and it didn’t pass the online judge.

public int uniquePaths(int m, int n) {
return dfs(0,0,m,n);
}

public int dfs(int i, int j, int m, int n){
if(i==m-1 && j==n-1){
return 1;
}

```
if(i<m-1 && j<n-1){
return dfs(i+1,j,m,n) + dfs(i,j+1,m,n);
}
```
```
if(i<m-1){
return dfs(i+1,j,m,n);
}
```
```
if(j<n-1){
return dfs(i,j+1,m,n);
}
```
return 0;
}

**132.2 Java Solution 2 - Dynamic Programming**

public int uniquePaths(int m, int n) {
if(m==0 || n==0) return 0;
if(m==1 || n==1) return 1;

329 | 677


132 Unique Paths

```
int[][] dp = new int[m][n];
```
```
//left column
for(int i=0; i<m; i++){
dp[i][0] = 1;
}
```
```
//top row
for(int j=0; j<n; j++){
dp[0][j] = 1;
}
```
```
//fill up the dp table
for(int i=1; i<m; i++){
for(int j=1; j<n; j++){
dp[i][j] = dp[i-1][j] + dp[i][j-1];
}
}
```
return dp[m-1][n-1];
}

330 | 677 Program Creek


## 133 Decode Ways

A message containing letters from A-Z is being encoded to numbers using the follow-
ing mapping:
’A’ -> 1 ’B’ -> 2 ... ’Z’ -> 26
Given an encoded message containing digits, determine the total number of ways
to decode it.

**133.1 Java Solution**

This problem can be solve by using dynamic programming. It is similar to the problem
of counting ways of climbing stairs. The relation is dp[n]=dp[n- 1 ]+dp[n- 2 ].

public int numDecodings(String s) {
if(s==null || s.length()==0 || s.charAt(0)==’0’)
return 0;
if(s.length()==1)
return 1;

```
int[] dp = new int[s.length()];
dp[0]=1;
if(Integer.parseInt(s.substring(0,2))>26){
if(s.charAt(1)!=’0’){
dp[1]=1;
}else{
dp[1]=0;
}
}else{
if(s.charAt(1)!=’0’){
dp[1]=2;
}else{
dp[1]=1;
}
}
```
```
for(int i=2; i<s.length(); i++){
if(s.charAt(i)!=’0’){
dp[i]+=dp[i-1];
}
```
```
int val = Integer.parseInt(s.substring(i-1, i+1));
if(val<=26 && val >=10){
dp[i]+=dp[i-2];
```
331 | 677


133 Decode Ways

### }

### }

return dp[s.length()-1];
}

332 | 677 Program Creek


## 134 Longest Common Subsequence

The longest common subsequence (LCS) problem is the problem of finding the longest

subsequence common to all sequences in a set of sequences (often just two sequences).

**134.1 Analysis**

**134.2 Java Solution**

public static int getLongestCommonSubsequence(String a, String b){
int m = a.length();
int n = b.length();
int[][] dp = new int[m+1][n+1];

```
for(int i=0; i<=m; i++){
for(int j=0; j<=n; j++){
if(i==0 || j==0){
dp[i][j]=0;
}else if(a.charAt(i-1)==b.charAt(j-1)){
dp[i][j] = 1 + dp[i-1][j-1];
}else{
dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
}
}
```
333 | 677


134 Longest Common Subsequence

### }

return dp[m][n];
}

334 | 677 Program Creek


## 135 Longest Common Substring

In computer science, the longest common substring problem is to find the longest
string that is a substring of two or more strings.

**135.1 Analysis**

Given two strings a and b, let dp[i][j] be the length of the common substring ending
at a[i] and b[j].

The dp table looks like the following given a="abc" and b="abcd".

**135.2 Java Solution**

335 | 677


135 Longest Common Substring

public static int getLongestCommonSubstring(String a, String b){
int m = a.length();
int n = b.length();

```
int max = 0;
```
```
int[][] dp = new int[m][n];
```
```
for(int i=0; i<m; i++){
for(int j=0; j<n; j++){
if(a.charAt(i) == b.charAt(j)){
if(i==0 || j==0){
dp[i][j]=1;
}else{
dp[i][j] = dp[i-1][j-1]+1;
}
```
```
if(max < dp[i][j])
max = dp[i][j];
}
```
```
}
}
```
return max;
}

This is a similar problem like longest common subsequence. The difference of the
solution is that for this problem when a[i]!=b[j], dp[i][j] are all zeros by default. How-

ever, in the longest common subsequence problem, dp[i][j] values are carried from the
previous values, i.e., dp[i- 1 ][j] and dp[i][j- 1 ].

336 | 677 Program Creek


## 136 Longest Increasing Subsequence

Given an unsorted array of integers, find the length of longest increasing subsequence.
For example, given [ 10 , 9 , 2 , 5 , 3 , 7 , 101 , 18 ], the longest increasing subsequence is

[ 2 , 3 , 7 , 101 ]. Therefore the length is 4.

**136.1 Java Solution 1 - Dynamic Programming**

Let max[i] represent the length of the longest increasing subsequence so far. If any
element before i is smaller than nums[i], then max[i] = max(max[i], max[j]+ 1 ).

Here is an example:

public int lengthOfLIS(int[] nums) {
if(nums==null || nums.length==0)
return 0;

```
int[] max = new int[nums.length];
```
```
for(int i=0; i<nums.length; i++){
max[i]=1;
```
337 | 677


136 Longest Increasing Subsequence

```
for(int j=0; j<i;j++){
if(nums[i]>nums[j]){
max[i]=Math.max(max[i], max[j]+1);
}
}
}
```
int result = 0;
for(int i=0; i<max.length; i++){
if(max[i]>result)
result = max[i];
}
return result;
}

Or, simplify the code as:

public int lengthOfLIS(int[] nums) {
if(nums==null || nums.length==0)
return 0;

```
int[] max = new int[nums.length];
Arrays.fill(max, 1);
```
```
int result = 1;
for(int i=0; i<nums.length; i++){
for(int j=0; j<i; j++){
if(nums[i]>nums[j]){
max[i]= Math.max(max[i], max[j]+1);
```
```
}
}
result = Math.max(max[i], result);
}
```
return result;
}

**136.2 Java Solution 2 - O(nlog(n))**

We can put the increasing sequence in a list.

for each num in nums
if(list.size()==0)
add num to list
else if(num > last element in list)
add num to list
else

338 | 677 Program Creek


```
136 Longest Increasing Subsequence
```
```
replace the element in the list which is the smallest but bigger than
num
```
public int lengthOfLIS(int[] nums) {
if(nums==null || nums.length==0)
return 0;

```
ArrayList<Integer> list = new ArrayList<Integer>();
```
```
for(int num: nums){
if(list.size()==0){
list.add(num);
}else if(num>list.get(list.size()-1)){
list.add(num);
}else{
int i=0;
int j=list.size()-1;
```
```
while(i<j){
int mid = (i+j)/2;
if(list.get(mid) < num){
i=mid+1;
}else{
j=mid;
}
}
```
```
list.set(j, num);
}
}
```
```
return list.size();
```
Program Creek 339 | 677


136 Longest Increasing Subsequence

### }

340 | 677 Program Creek


## 137 Coin Change

You are given coins of different denominations and a total amount of money amount.

Write a function to compute the fewest number of coins that you need to make up that
amount. If that amount of money cannot be made up by any combination of the coins,
return - 1.

**137.1 Java Solution 1 - Dynamic Programming**

Let dp[v] to be the minimum number of coins required to get the amount v.
dp[i+a_coin] = min(dp[i+a_coin], dp[i]+1) if dp[i] is reachable.
dp[i+a_coin] = dp[i+a_coin] is dp[i] is not reachable.
We initially set dp[i] to be MAX_VALUE.

Here is the Java code:

public int coinChange(int[] coins, int amount) {
if(amount==0) return 0;

```
int[] dp = new int [amount+1];
dp[0]=0; // do not need any coin to get 0 amount
for(int i=1;i<=amount; i++)
dp[i]= Integer.MAX_VALUE;
```
```
for(int i=0; i<=amount; i++){
for(int coin: coins){
if(i+coin <=amount){
if(dp[i]==Integer.MAX_VALUE){
dp[i+coin] = dp[i+coin];
}else{
dp[i+coin] = Math.min(dp[i+coin], dp[i]+1);
}
}
}
}
```
```
if(dp[amount] >= Integer.MAX_VALUE)
return -1;
```
return dp[amount];
}

This clean solution takes time O(nˆ 2 ).

341 | 677


137 Coin Change

**137.2 Java Solution 2 - Breath First Search (BFS)**

Most dynamic programming problems can be solved by using BFS.
We can view this problem as going to a target position with steps that are allows in

the array coins. We maintain two queues: one of the amount so far and the other for
the minimal steps. The time is too much because of the contains method take n and
total time is O(n 3 ˆ).

public int coinChange(int[] coins, int amount) {
if (amount == 0)
return 0;

```
LinkedList<Integer> amountQueue = new LinkedList<Integer>();
LinkedList<Integer> stepQueue = new LinkedList<Integer>();
```
```
// to get 0, 0 step is required
amountQueue.offer(0);
stepQueue.offer(0);
```
```
while (amountQueue.size() > 0) {
int temp = amountQueue.poll();
int step = stepQueue.poll();
```
```
if (temp == amount)
return step;
```
```
for (int coin : coins) {
if (temp > amount) {
continue;
} else {
if (!amountQueue.contains(temp + coin)) {
amountQueue.offer(temp + coin);
stepQueue.offer(step + 1);
}
}
}
}
```
return -1;
}

342 | 677 Program Creek


## 138 Perfect Squares

Given a positive integer n, find the least number of perfect square numbers (for exam-
ple, 1 , 4 , 9 , 16 , ...) which sum to n.
For example, given n = 12 , return 3 because 12 = 4 + 4 + 4 ; given n = 13 , return 2
because 13 = 4 + 9.

**138.1 Java Solution**

This is a dp problem. The key is to find the relation which is dp[i] = min(dp[i], dp[i-
square]+ 1 ). For example, dp[ 5 ]=dp[ 4 ]+ 1 = 1 + 1 = 2.

public int numSquares(int n) {
int max = (int) Math.sqrt(n);

```
int[] dp = new int[n+1];
Arrays.fill(dp, Integer.MAX_VALUE);
```
```
for(int i=1; i<=n; i++){
for(int j=1; j<=max; j++){
if(i==j*j){
dp[i]=1;
}else if(i>j*j){
dp[i]=Math.min(dp[i], dp[i-j*j] + 1);
}
}
}
```
return dp[n];
}

343 | 677



## 139 Permutations

Given a collection of numbers, return all possible permutations.

For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].

**139.1 Java Solution 1**

We can get all permutations by the following steps:

[1]
[2, 1]
[1, 2]
[3, 2, 1]
[2, 3, 1]
[2, 1, 3]
[3, 1, 2]
[1, 3, 2]
[1, 2, 3]

Loop through the array, in each iteration, a new number is added to different loca-
tions of results of previous iteration. Start from an empty List.

public ArrayList<ArrayList<Integer>> permute(int[] num) {
ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

```
//start from an empty list
result.add(new ArrayList<Integer>());
```
```
for (int i = 0; i < num.length; i++) {
//list of list in current iteration of the array num
ArrayList<ArrayList<Integer>> current = new
ArrayList<ArrayList<Integer>>();
```
```
for (ArrayList<Integer> l : result) {
// # of locations to insert is largest index + 1
for (int j = 0; j < l.size()+1; j++) {
// + add num[i] to different locations
l.add(j, num[i]);
```
```
ArrayList<Integer> temp = new ArrayList<Integer>(l);
```
345 | 677


139 Permutations

```
current.add(temp);
```
```
//System.out.println(temp);
```
```
// - remove num[i] add
l.remove(j);
}
}
```
```
result = new ArrayList<ArrayList<Integer>>(current);
}
```
return result;
}

**139.2 Java Solution 2**

We can also recursively solve this problem. Swap each element with each element
after it.

public ArrayList<ArrayList<Integer>> permute(int[] num) {
ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
permute(num, 0, result);
return result;
}

void permute(int[] num, int start, ArrayList<ArrayList<Integer>> result) {

```
if (start >= num.length) {
ArrayList<Integer> item = convertArrayToList(num);
result.add(item);
}
```
for (int j = start; j <= num.length - 1; j++) {
swap(num, start, j);
permute(num, start + 1, result);
swap(num, start, j);
}
}

private ArrayList<Integer> convertArrayToList(int[] num) {
ArrayList<Integer> item = new ArrayList<Integer>();
for (int h = 0; h < num.length; h++) {
item.add(num[h]);
}
return item;
}

346 | 677 Program Creek


```
139 Permutations
```
private void swap(int[] a, int i, int j) {
int temp = a[i];
a[i] = a[j];
a[j] = temp;
}

Program Creek 347 | 677



## 140 Permutations II

Given a collection of numbers that might contain duplicates, return all possible unique
permutations.

For example, [1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1].

**140.1 Basic Idea**

For each number in the array, swap it with every element after it. To avoid duplicate,
we need to check the existing sequence first.

**140.2 Java Solution 1**

public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
permuteUnique(num, 0, result);
return result;
}

private void permuteUnique(int[] num, int start,
ArrayList<ArrayList<Integer>> result) {

```
if (start >= num.length ) {
ArrayList<Integer> item = convertArrayToList(num);
result.add(item);
}
```
for (int j = start; j <= num.length-1; j++) {
if (containsDuplicate(num, start, j)) {
swap(num, start, j);
permuteUnique(num, start + 1, result);
swap(num, start, j);
}
}
}

private ArrayList<Integer> convertArrayToList(int[] num) {
ArrayList<Integer> item = new ArrayList<Integer>();
for (int h = 0; h < num.length; h++) {

349 | 677


140 Permutations II

item.add(num[h]);
}
return item;
}

private boolean containsDuplicate(int[] arr, int start, int end) {
for (int i = start; i <= end-1; i++) {
if (arr[i] == arr[end]) {
return false;
}
}
return true;
}

private void swap(int[] a, int i, int j) {
int temp = a[i];
a[i] = a[j];
a[j] = temp;
}

**140.3 Java Solution 2**

Use set to maintain uniqueness:

public static ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
ArrayList<ArrayList<Integer>> returnList = new
ArrayList<ArrayList<Integer>>();
returnList.add(new ArrayList<Integer>());

```
for (int i = 0; i < num.length; i++) {
Set<ArrayList<Integer>> currentSet = new HashSet<ArrayList<Integer>>();
for (List<Integer> l : returnList) {
for (int j = 0; j < l.size() + 1; j++) {
l.add(j, num[i]);
ArrayList<Integer> T = new ArrayList<Integer>(l);
l.remove(j);
currentSet.add(T);
}
}
returnList = new ArrayList<ArrayList<Integer>>(currentSet);
}
```
return returnList;
}

Thanks to Milan for such a simple solution!

350 | 677 Program Creek


## 141 Permutation Sequence

The set [ 1 , 2 , 3 ,... ,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, We get the following se-
quence (ie, for n = 3 ):

"123"
"132"
"213"
"231"
"312"
"321"

Given n and k, return the kth permutation sequence. (Note: Given n will be between
1 and 9 inclusive.)

**141.1 Java Solution 1**

public class Solution {
public String getPermutation(int n, int k) {

```
// initialize all numbers
ArrayList<Integer> numberList = new ArrayList<Integer>();
for (int i = 1; i <= n; i++) {
numberList.add(i);
}
```
```
// change k to be index
k--;
```
```
// set factorial of n
int mod = 1;
for (int i = 1; i <= n; i++) {
mod = mod*i;
}
```
```
String result = "";
```
```
// find sequence
for (int i = 0; i < n; i++) {
mod = mod / (n - i);
// find the right number(curIndex) of
int curIndex = k / mod;
```
351 | 677


141 Permutation Sequence

```
// update k
k = k % mod;
```
```
// get number according to curIndex
result += numberList.get(curIndex);
// remove from list
numberList.remove(curIndex);
}
```
return result.toString();
}
}

**141.2 Java Solution 2**

public class Solution {
public String getPermutation(int n, int k) {
boolean[] output = new boolean[n];
StringBuilder buf = new StringBuilder("");

```
int[] res = new int[n];
res[0] = 1;
```
```
for (int i = 1; i < n; i++)
res[i] = res[i - 1]* i;
```
```
for (int i = n - 1; i >= 0; i--) {
int s = 1;
```
```
while (k > res[i]) {
s++;
k = k - res[i];
}
```
```
for (int j = 0; j < n; j++) {
if (j + 1 <= s && output[j]) {
s++;
}
}
```
```
output[s - 1] = true;
buf.append(Integer.toString(s));
}
```
return buf.toString();
}
}

352 | 677 Program Creek


## 142 Generate Parentheses

Given n pairs of parentheses, write a function to generate all combinations of well-
formed parentheses.

For example, given n = 3 , a solution set is:

"((()))", "(()())", "(())()", "()(())", "()()()"

**142.1 Java Solution 1 - DFS**

This solution is simple and clear. In the dfs() method, left stands for the remaining

number of (, right stands for the remaining number of ).

public List<String> generateParenthesis(int n) {
ArrayList<String> result = new ArrayList<String>();
dfs(result, "", n, n);
return result;
}
/*
left and right represents the remaining number of ( and ) that need to be
added.
When left > right, there are more ")" placed than "(". Such cases are wrong
and the method stops.

*/
public void dfs(ArrayList<String> result, String s, int left, int right){
if(left > right)
return;

```
if(left==0&&right==0){
result.add(s);
return;
}
```
```
if(left>0){
dfs(result, s+"(", left-1, right);
}
```
if(right>0){
dfs(result, s+")", left, right-1);
}
}

353 | 677


142 Generate Parentheses

**142.2 Java Solution 2**

This solution looks more complicated. ,You can use n= 2 to walk though the code.

public List<String> generateParenthesis(int n) {
ArrayList<String> result = new ArrayList<String>();
ArrayList<Integer> diff = new ArrayList<Integer>();

```
result.add("");
diff.add(0);
```
```
for (int i = 0; i < 2* n; i++) {
ArrayList<String> temp1 = new ArrayList<String>();
ArrayList<Integer> temp2 = new ArrayList<Integer>();
```
```
for (int j = 0; j < result.size(); j++) {
String s = result.get(j);
int k = diff.get(j);
```
```
if (i < 2* n - 1) {
temp1.add(s + "(");
temp2.add(k + 1);
}
```
```
if (k > 0 && i < 2*n - 1 || k == 1 && i == 2 *n - 1) {
temp1.add(s + ")");
temp2.add(k - 1);
}
}
```
```
result = new ArrayList<String>(temp1);
diff = new ArrayList<Integer>(temp2);
}
```
return result;
}

354 | 677 Program Creek


## 143 Combination Sum

Given a set of candidate numbers (C) and a target number (T), find all unique combi-

nations in C where the candidate numbers sums to T. The same repeated number may
be chosen from C unlimited number of times.
Note: All numbers (including target) will be positive integers. Elements in a combi-
nation (a 1 , a 2 , ... , ak) must be in non-descending order. (ie, a 1 <= a 2 <= ... <= ak). The

solution set must not contain duplicate combinations. For example, given candidate
set 2 , 3 , 6 , 7 and target 7 , A solution set is:

[7]
[2, 2, 3]

**143.1 Thoughts**

The first impression of this problem should be depth-first search(DFS). To solve DFS
problem, recursion is a normal implementation.
Note that the candidates array is not sorted, we need to sort it first.

**143.2 Java Solution**

public ArrayList<ArrayList<Integer>> combinationSum(int[] candidates, int
target) {
ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

```
if(candidates == null || candidates.length == 0) return result;
```
```
ArrayList<Integer> current = new ArrayList<Integer>();
Arrays.sort(candidates);
```
```
combinationSum(candidates, target, 0, current, result);
```
return result;
}

public void combinationSum(int[] candidates, int target, int j,
ArrayList<Integer> curr, ArrayList<ArrayList<Integer>> result){
if(target == 0){
ArrayList<Integer> temp = new ArrayList<Integer>(curr);
result.add(temp);

355 | 677


143 Combination Sum

```
return;
}
```
```
for(int i=j; i<candidates.length; i++){
if(target < candidates[i])
return;
```
curr.add(candidates[i]);
combinationSum(candidates, target - candidates[i], i, curr, result);
curr.remove(curr.size()-1);
}
}

356 | 677 Program Creek


## 144 Combination Sum II

Given a collection of candidate numbers (C) and a target number (T), find all unique

combinations in C where the candidate numbers sums to T. Each number in C may
only be used ONCE in the combination.
Note: 1 ) All numbers (including target) will be positive integers. 2 ) Elements in a
combination (a 1 , a 2 ,... , ak) must be in non-descending order. (ie, a 1 ≤a 2 ≤... ≤

ak). 3 ) The solution set must not contain duplicate combinations.

**144.1 Java Solution**

This problem is an extension of Combination Sum. The difference is one number in
the array can only be used ONCE.

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
List<List<Integer>> result = new ArrayList<List<Integer>>();
List<Integer> curr = new ArrayList<Integer>();
Arrays.sort(candidates);
helper(result, curr, 0, target, candidates);
return result;
}

public void helper(List<List<Integer>> result, List<Integer> curr, int start,
int target, int[] candidates){
if(target==0){
result.add(new ArrayList<Integer>(curr));
return;
}
if(target<0){
return;
}

int prev=-1;
for(int i=start; i<candidates.length; i++){
if(prev!=candidates[i]){ // each time start from different element
curr.add(candidates[i]);
helper(result, curr, i+1, target-candidates[i], candidates); // and
use next element only
curr.remove(curr.size()-1);
prev=candidates[i];
}
}
}

357 | 677



## 145 Combination Sum III

Find all possible combinations of k numbers that add up to a number n, given that

only numbers from 1 to 9 can be used and each combination should be a unique set
of numbers.
Ensure that numbers within the set are sorted in ascending order.
Example 1 : Input: k = 3 , n = 7 Output: [[ 1 , 2 , 4 ]] Example 2 : Input: k = 3 , n = 9
Output: [[ 1 , 2 , 6 ], [ 1 , 3 , 5 ], [ 2 , 3 , 4 ]]

**145.1 Analysis**

Related problems: Combination Sum, Combination Sum II.

**145.2 Java Solution**

public List<List<Integer>> combinationSum3(int k, int n) {
List<List<Integer>> result = new ArrayList<List<Integer>>();
List<Integer> curr = new ArrayList<Integer>();
helper(result, curr, k, 1, n);
return result;
}

public void helper(List<List<Integer>> result, List<Integer> curr, int k, int
start, int sum){
if(sum<0){
return;
}

```
if(sum==0 && curr.size()==k){
result.add(new ArrayList<Integer>(curr));
return;
}
```
for(int i=start; i<=9; i++){
curr.add(i);
helper(result, curr, k, i+1, sum-i);
curr.remove(curr.size()-1);
}
}

Note the following relation in Java:

359 | 677


145 Combination Sum III

Integer is a subclass of Number and ArrayList is a subclass of List. But ArrayList is
not a subclass of ArrayList.

360 | 677 Program Creek


## 146 Combination Sum IV Contents

Given an integer array with all positive numbers and no duplicates, find the number
of possible combinations that add up to a positive integer target.

**146.1 Java Solution**

This problem is similar to Coin Change. It’s a typical dynamic programming problem.

public int combinationSum4(int[] nums, int target) {
if(nums==null || nums.length==0)
return 0;

```
int[] dp = new int[target+1];
```
```
dp[0]=1;
```
```
for(int i=0; i<=target; i++){
for(int num: nums){
if(i+num<=target){
dp[i+num]+=dp[i];
}
}
}
```
return dp[target];
}

361 | 677



## 147 Combinations

Given two integers n and k, return all possible combinations of k numbers out of 1 ...
n.
For example, if n = 4 and k = 2 , a solution is:

[
[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],
]

**147.1 Java Solution**

public ArrayList<ArrayList<Integer>> combine(int n, int k) {
ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

```
if (n <= 0 || n < k)
return result;
```
```
ArrayList<Integer> item = new ArrayList<Integer>();
dfs(n, k, 1, item, result); // because it need to begin from 1
```
return result;
}

private void dfs(int n, int k, int start, ArrayList<Integer> item,
ArrayList<ArrayList<Integer>> res) {
if (item.size() == k) {
res.add(new ArrayList<Integer>(item));
return;
}

for (int i = start; i <= n; i++) {
item.add(i);
dfs(n, k, i + 1, item, res);
item.remove(item.size() - 1);
}
}

363 | 677



## 148 Letter Combinations of a Phone Number

Given a digit string, return all possible letter combinations that the number could
represent. (Check out your cellphone to see the mappings) Input:Digit string " 23 ",
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

**148.1 Analysis**

This problem can be solves by a typical DFS algorithm. DFS problems are very similar
and can be solved by using a simple recursion. Check out the index page to see other
DFS problems.

**148.2 Java Solution**

public List<String> letterCombinations(String digits) {
HashMap<Integer, String> map = new HashMap<Integer, String>();
map.put(2, "abc");
map.put(3, "def");
map.put(4, "ghi");
map.put(5, "jkl");
map.put(6, "mno");
map.put(7, "pqrs");
map.put(8, "tuv");
map.put(9, "wxyz");
map.put(0, "");

```
ArrayList<String> result = new ArrayList<String>();
```
```
if(digits == null || digits.length() == 0)
return result;
```
```
ArrayList<Character> temp = new ArrayList<Character>();
getString(digits, temp, result, map);
```
return result;
}

public void getString(String digits, ArrayList<Character> temp,
ArrayList<String> result, HashMap<Integer, String> map){

365 | 677


148 Letter Combinations of a Phone Number

```
if(digits.length() == 0){
char[] arr = new char[temp.size()];
for(int i=0; i<temp.size(); i++){
arr[i] = temp.get(i);
}
result.add(String.valueOf(arr));
return;
}
```
Integer curr = Integer.valueOf(digits.substring(0,1));
String letters = map.get(curr);
for(int i=0; i<letters.length(); i++){
temp.add(letters.charAt(i));
getString(digits.substring(1), temp, result, map);
temp.remove(temp.size()-1);
}
}

I often found that I write a solution differently each time I solve a problem. Here is

another way of writing the solution.

public List<String> letterCombinations(String digits) {
HashMap<Character, char[]> map = new HashMap<Character, char[]>();
map.put(’2’, new char[]{’a’,’b’,’c’});
map.put(’3’, new char[]{’d’,’e’,’f’});
map.put(’4’, new char[]{’g’,’h’,’i’});
map.put(’5’, new char[]{’j’,’k’,’l’});
map.put(’6’, new char[]{’m’,’n’,’o’});
map.put(’7’, new char[]{’p’,’q’,’r’,’s’});
map.put(’8’, new char[]{’t’,’u’,’v’});
map.put(’9’, new char[]{’w’,’x’,’y’,’z’});

```
List<String> result = new ArrayList<String>();
if(digits.equals(""))
return result;
```
```
helper(result, new StringBuilder(), digits, 0, map);
```
```
return result;
```
}

public void helper(List<String> result, StringBuilder sb, String digits, int
index, HashMap<Character, char[]> map){
if(index>=digits.length()){
result.add(sb.toString());
return;
}

```
char c = digits.charAt(index);
```
366 | 677 Program Creek


```
148 Letter Combinations of a Phone Number
```
```
char[] arr = map.get(c);
```
for(int i=0; i<arr.length; i++){
sb.append(arr[i]);
helper(result, sb, digits, index+1, map);
sb.deleteCharAt(sb.length()-1);
}
}

Program Creek 367 | 677



## 149 Restore IP Addresses

Given a string containing only digits, restore it by returning all possible valid IP ad-
dress combinations.

For example: given " 25525511135 ",return [" 255. 255. 11. 135 ", " 255. 255. 111. 35 "].

**149.1 Java Solution**

This is a typical search problem and it can be solved by using DFS.

public List<String> restoreIpAddresses(String s) {
ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();
ArrayList<String> t = new ArrayList<String>();
dfs(result, s, 0, t);

```
ArrayList<String> finalResult = new ArrayList<String>();
```
```
for(ArrayList<String> l: result){
StringBuilder sb = new StringBuilder();
for(String str: l){
sb.append(str+".");
}
sb.setLength(sb.length() - 1);
finalResult.add(sb.toString());
}
```
return finalResult;
}

public void dfs(ArrayList<ArrayList<String>> result, String s, int start,
ArrayList<String> t){
//if already get 4 numbers, but s is not consumed, return
if(t.size()>=4 && start!=s.length())
return;

```
//make sure t’s size + remaining string’s length >=4
if((t.size()+s.length()-start+1)<4)
return;
```
```
//t’s size is 4 and no remaining part that is not consumed.
if(t.size()==4 && start==s.length()){
ArrayList<String> temp = new ArrayList<String>(t);
result.add(temp);
```
369 | 677


149 Restore IP Addresses

```
return;
}
```
```
for(int i=1; i<=3; i++){
//make sure the index is within the boundary
if(start+i>s.length())
break;
```
```
String sub = s.substring(start, start+i);
//handle case like 001. i.e., if length > 1 and first char is 0, ignore
the case.
if(i>1 && s.charAt(start)==’0’){
break;
}
```
```
//make sure each number <= 255
if(Integer.valueOf(sub)>255)
break;
```
t.add(sub);
dfs(result, s, start+i, t);
t.remove(t.size()-1);
}
}

370 | 677 Program Creek


## 150 Factor Combinations

Numbers can be regarded as product of its factors. For example,

8 = 2 x 2 x 2;
= 2 x 4.

Write a function that takes an integer n and return all possible combinations of its
factors.

Note: You may assume that n is always positive. Factors should be greater than 1
and less than n.

**150.1 Java Solution**

public List<List<Integer>> getFactors(int n) {
List<List<Integer>> result = new ArrayList<List<Integer>>();
List<Integer> list = new ArrayList<Integer>();
helper(2, 1, n, result, list);
return result;
}

public void helper(int start, int product, int n, List<List<Integer>> result,
List<Integer> curr){
if(start>n || product > n )
return ;

```
if(product==n) {
ArrayList<Integer> t = new ArrayList<Integer>(curr);
result.add(t);
return;
}
```
```
for(int i=start; i<n; i++){
if(i*product>n)
break;
```
if(n%i==0){
curr.add(i);
helper(i, i*product, n, result, curr);
curr.remove(curr.size()-1);
}
}
}

371 | 677


150 Factor Combinations

372 | 677 Program Creek


## 151 Subsets

Given a set of distinct integers, S, return all possible subsets.
Note: 1 ) Elements in a subset must be in non-descending order. 2 ) The solution set
must not contain duplicate subsets.

For example, given S = [1,2,3], the method returns:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]

**151.1 Thoughts**

Given a set S of n distinct integers, there is a relation between Sn and Sn- 1. The subset

of Sn- 1 is the union of subset of Sn- 1 and each element in Sn- 1 + one more element.
Therefore, a Java solution can be quickly formalized.

**151.2 Java Solution**

public ArrayList<ArrayList<Integer>> subsets(int[] S) {
if (S == null)
return null;

```
Arrays.sort(S);
```
```
ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
```
```
for (int i = 0; i < S.length; i++) {
ArrayList<ArrayList<Integer>> temp = new ArrayList<ArrayList<Integer>>();
```
```
//get sets that are already in result
for (ArrayList<Integer> a : result) {
temp.add(new ArrayList<Integer>(a));
```
373 | 677


151 Subsets

### }

```
//add S[i] to existing sets
for (ArrayList<Integer> a : temp) {
a.add(S[i]);
}
```
```
//add S[i] only as a set
ArrayList<Integer> single = new ArrayList<Integer>();
single.add(S[i]);
temp.add(single);
```
```
result.addAll(temp);
}
```
```
//add empty set
result.add(new ArrayList<Integer>());
```
return result;
}

374 | 677 Program Creek


## 152 Subsets II

Given a set of distinct integers, S, return all possible subsets.
Note: Elements in a subset must be in non-descending order. The solution set must

not contain duplicate subsets. For example, If S = [ 1 , 2 , 3 ], a solution is:

[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]

**152.1 Thoughts**

Comparing this problem with Subsets can help better understand the problem.

**152.2 Java Solution**

public ArrayList<ArrayList<Integer>> subsetsWithDup(int[] num) {
if (num == null)
return null;

```
Arrays.sort(num);
```
```
ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
ArrayList<ArrayList<Integer>> prev = new ArrayList<ArrayList<Integer>>();
```
```
for (int i = num.length-1; i >= 0; i--) {
```
```
//get existing sets
if (i == num.length - 1 || num[i] != num[i + 1] || prev.size() == 0) {
prev = new ArrayList<ArrayList<Integer>>();
for (int j = 0; j < result.size(); j++) {
prev.add(new ArrayList<Integer>(result.get(j)));
}
}
```
375 | 677


152 Subsets II

```
//add current number to each element of the set
for (ArrayList<Integer> temp : prev) {
temp.add(0, num[i]);
}
```
```
//add each single number as a set, only if current element is different
with previous
if (i == num.length - 1 || num[i] != num[i + 1]) {
ArrayList<Integer> temp = new ArrayList<Integer>();
temp.add(num[i]);
prev.add(temp);
}
```
```
//add all set created in this iteration
for (ArrayList<Integer> temp : prev) {
result.add(new ArrayList<Integer>(temp));
}
}
```
```
//add empty set
result.add(new ArrayList<Integer>());
```
return result;
}

Feed the method [ 1 , 2 , 3 ] the following will be result at each iteration.

[2]
[2][2,2]
[2][2,2][1,2][1,2,2][1]
Get [] finally.

376 | 677 Program Creek


## 153 Triangle

Given a triangle, find the minimum path sum from top to bottom. Each step you may
move to adjacent numbers on the row below.
For example, given the following triangle

[
[2],
[3,4],
[6,5,7],
[4,1,8,3]
]

```
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11 ).
Note: Bonus point if you are able to do this using only O(n) extra space, where n is
```
the total number of rows in the triangle.

**153.1 Bottom-Up (Good Solution)**

We can actually start from the bottom of the triangle.

public int minimumTotal(ArrayList<ArrayList<Integer>> triangle) {
int[] total = new int[triangle.size()];
int l = triangle.size() - 1;

```
for (int i = 0; i < triangle.get(l).size(); i++) {
total[i] = triangle.get(l).get(i);
}
```
```
// iterate from last second row
for (int i = triangle.size() - 2; i >= 0; i--) {
for (int j = 0; j < triangle.get(i + 1).size() - 1; j++) {
total[j] = triangle.get(i).get(j) + Math.min(total[j], total[j + 1]);
}
}
```
return total[0];
}

377 | 677



## 154 String to Integer (atoi)

Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do

not see below and ask yourself what are the possible input cases.

**154.1 Analysis**

The following cases should be considered for this problem:

1. null or empty string
2. white spaces
3. +/- sign
4. calculate real value
5. handle min & max

**154.2 Java Solution**

public int atoi(String str) {
if (str == null || str.length() < 1)
return 0;

```
// trim white spaces
str = str.trim();
```
```
char flag = ’+’;
```
```
// check negative or positive
int i = 0;
if (str.charAt(0) == ’-’) {
flag = ’-’;
i++;
} else if (str.charAt(0) == ’+’) {
i++;
}
// use double to store result
double result = 0;
```
```
// calculate value
while (str.length() > i && str.charAt(i) >= ’0’ && str.charAt(i) <= ’9’) {
result = result *10 + (str.charAt(i) - ’0’);
```
379 | 677


154 String to Integer (atoi)

```
i++;
}
```
```
if (flag == ’-’)
result = -result;
```
```
// handle max and min
if (result > Integer.MAX_VALUE)
return Integer.MAX_VALUE;
```
```
if (result < Integer.MIN_VALUE)
return Integer.MIN_VALUE;
```
return (int) result;
}

380 | 677 Program Creek


## 155 Implement strStr()

Problem:
Implement strStr(). Returns the index of the first occurrence of needle in haystack, or - _1_
if needle is not part of haystack.

**155.1 Java Solution 1 - Naive**

public int strStr(String haystack, String needle) {
if(haystack==null || needle==null)
return 0;

```
if(needle.length() == 0)
return 0;
```
```
for(int i=0; i<haystack.length(); i++){
if(i + needle.length() > haystack.length())
return -1;
```
```
int m = i;
for(int j=0; j<needle.length(); j++){
if(needle.charAt(j)==haystack.charAt(m)){
if(j==needle.length()-1)
return i;
m++;
}else{
break;
}
```
```
}
}
```
return -1;
}

**155.2 Java Solution 2 - KMP**

Check out this article to understand KMP algorithm.

public int strStr(String haystack, String needle) {
if(haystack==null || needle==null)

381 | 677


155 Implement strStr()

```
return 0;
```
```
int h = haystack.length();
int n = needle.length();
```
```
if (n > h)
return -1;
if (n == 0)
return 0;
```
```
int[] next = getNext(needle);
int i = 0;
```
```
while (i <= h - n) {
int success = 1;
for (int j = 0; j < n; j++) {
if (needle.charAt(0) != haystack.charAt(i)) {
success = 0;
i++;
break;
} else if (needle.charAt(j) != haystack.charAt(i + j)) {
success = 0;
i = i + j - next[j - 1];
break;
}
}
if (success == 1)
return i;
}
```
return -1;
}

//calculate KMP array
public int[] getNext(String needle) {
int[] next = new int[needle.length()];
next[0] = 0;

```
for (int i = 1; i < needle.length(); i++) {
int index = next[i - 1];
while (index > 0 && needle.charAt(index) != needle.charAt(i)) {
index = next[index - 1];
}
```
```
if (needle.charAt(index) == needle.charAt(i)) {
next[i] = next[i - 1] + 1;
} else {
next[i] = 0;
}
}
```
382 | 677 Program Creek


```
155 Implement strStr()
```
return next;
}

Program Creek 383 | 677



## 156 ZigZag Conversion

The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of
rows like this: (you may want to display this pattern in a fixed font for better legibility)

P A H N
A P L S I I G
Y I R

And then read line by line: "PAHNAPLSIIGYIR" Write the a method convert("PAYPALISHIRING",
3 ) which returns "PAHNAPLSIIGYIR".

**156.1 Java Solution**

public String convert(String s, int numRows) {
if (numRows == 1)
return s;

```
StringBuilder sb = new StringBuilder();
// step
int step = 2 *numRows - 2;
```
```
for (int i = 0; i < numRows; i++) {
//first & last rows
if (i == 0 || i == numRows - 1) {
for (int j = i; j < s.length(); j = j + step) {
sb.append(s.charAt(j));
}
//middle rows
} else {
int j = i;
boolean flag = true;
int step1 = 2*(numRows - 1 - i);
int step2 = step - step1;
```
```
while (j < s.length()) {
sb.append(s.charAt(j));
if (flag)
j = j + step1;
else
j = j + step2;
flag = !flag;
}
```
385 | 677


156 ZigZag Conversion

### }

### }

return sb.toString();
}

386 | 677 Program Creek


## 157 Add Binary

Given two binary strings, return their sum (also a binary string).
For example, a = " 11 ", b = " 1 ", the return is " 100 ".

**157.1 Java Solution**

Very simple, nothing special. Note how to convert a character to an int.

public String addBinary(String a, String b) {
if(a==null || a.length()==0)
return b;
if(b==null || b.length()==0)
return a;

```
int pa = a.length()-1;
int pb = b.length()-1;
```
```
int flag = 0;
StringBuilder sb = new StringBuilder();
while(pa >= 0 || pb >=0){
int va = 0;
int vb = 0;
```
```
if(pa >= 0){
va = a.charAt(pa)==’0’? 0 : 1;
pa--;
}
if(pb >= 0){
vb = b.charAt(pb)==’0’? 0: 1;
pb--;
}
```
```
int sum = va + vb + flag;
if(sum >= 2){
sb.append(String.valueOf(sum-2));
flag = 1;
}else{
flag = 0;
sb.append(String.valueOf(sum));
}
}
```
```
if(flag == 1){
```
387 | 677


157 Add Binary

```
sb.append("1");
}
```
String reversed = sb.reverse().toString();
return reversed;
}

388 | 677 Program Creek


## 158 Length of Last Word

Given a string s consists of upper/lower-case alphabets and empty space characters ’
’, return the length of last word in the string. If the last word does not exist, return 0.

**158.1 Java Solution**

Very simple question. We just need a flag to mark the start of letters from the end. If
a letter starts and the next character is not a letter, return the length.

public int lengthOfLastWord(String s) {
if(s==null || s.length() == 0)
return 0;

```
int result = 0;
int len = s.length();
```
```
boolean flag = false;
for(int i=len-1; i>=0; i--){
char c = s.charAt(i);
if((c>=’a’ && c<=’z’) || (c>=’A’ && c<=’Z’)){
flag = true;
result++;
}else{
if(flag)
return result;
}
}
```
return result;
}

389 | 677



## 159 Bulls and Cows

You are playing the following Bulls and Cows game with your friend: You write down

a number and ask your friend to guess what the number is. Each time your friend
makes a guess, you provide a hint that indicates how many digits in said guess match
your secret number exactly in both digit and position (called "bulls") and how many
digits match the secret number but locate in the wrong position (called "cows"). Your

friend will use successive guesses and hints to eventually derive the secret number.
For example: Secret number: " 1807 " Friend’s guess: " 7810 "
Hint: 1 bull and 3 cows. (The bull is 8 , the cows are 0 , 1 and 7 .) Write a function to

return a hint according to the secret number and friend’s guess, use A to indicate the
bulls and B to indicate the cows. In the above example, your function should return
" 1 A 3 B".

**159.1 Java Solution 1 - Using HashMap**

public String getHint(String secret, String guess) {
int countBull=0;
int countCow=0;

```
HashMap<Character, Integer> map = new HashMap<Character, Integer>();
```
```
//check bull
for(int i=0; i<secret.length(); i++){
char c1 = secret.charAt(i);
char c2 = guess.charAt(i);
```
```
if(c1==c2){
countBull++;
}else{
if(map.containsKey(c1)){
int freq = map.get(c1);
freq++;
map.put(c1, freq);
}else{
map.put(c1, 1);
}
}
}
```
```
//check cow
```
391 | 677


159 Bulls and Cows

```
for(int i=0; i<secret.length(); i++){
char c1 = secret.charAt(i);
char c2 = guess.charAt(i);
```
```
if(c1!=c2){
if(map.containsKey(c2)){
countCow++;
if(map.get(c2)==1){
map.remove(c2);
}else{
int freq = map.get(c2);
freq--;
map.put(c2, freq);
}
}
}
}
```
return countBull+"A"+countCow+"B";
}

**159.2 Java Solution 2 - Using an Array**

Since the secret and guess only contain numbers and there are at most 10 possible

digits, we can use two arrays to track the frequency of each digits in secret and guess.

public String getHint(String secret, String guess) {
int countBull=0;
int countCow =0;
int[] arr1 = new int[10];
int[] arr2 = new int[10];

```
for(int i=0; i<secret.length(); i++){
char c1 = secret.charAt(i);
char c2 = guess.charAt(i);
```
```
if(c1==c2)
countBull++;
else{
arr1[c1-’0’]++;
arr2[c2-’0’]++;
}
}
```
```
for(int i=0; i<10; i++){
countCow += Math.min(arr1[i], arr2[i]);
}
```
392 | 677 Program Creek


```
159 Bulls and Cows
```
return countBull+"A"+countCow+"B";
}

Program Creek 393 | 677



## 160 Longest Common Prefix

**160.1 Problem**

Write a function to find the longest common prefix string amongst an array of strings.

**160.2 Analysis**

To solve this problem, we need to find the two loop conditions. One is the length of
the shortest string. The other is iteration over every element of the string array.

**160.3 Java Solution**

public String longestCommonPrefix(String[] strs) {
if(strs==null || strs.length==0){
return "";
}

```
if(strs.length==1)
return strs[0];
```
```
int minLen = strs.length+1;
```
```
for(String str: strs){
if(minLen > str.length()){
minLen = str.length();
}
}
```
```
for(int i=0; i<minLen; i++){
for(int j=0; j<strs.length-1; j++){
String s1 = strs[j];
String s2 = strs[j+1];
if(s1.charAt(i)!=s2.charAt(i)){
return s1.substring(0, i);
}
}
}
```
return strs[0].substring(0, minLen);
}

395 | 677



## 161 Simplify Path

Given an absolute path for a file (Unix-style), simplify it.
For example,

path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"
path = "/../", => "/"
path = "/home//foo/", => "/home/foo"

**161.1 Java Solution**

public String simplifyPath(String path) {
Stack<String> stack = new Stack<String>();

```
//stack.push(path.substring(0,1));
```
```
while(path.length()> 0 && path.charAt(path.length()-1) ==’/’){
path = path.substring(0, path.length()-1);
}
```
```
int start = 0;
for(int i=1; i<path.length(); i++){
if(path.charAt(i) == ’/’){
stack.push(path.substring(start, i));
start = i;
}else if(i==path.length()-1){
stack.push(path.substring(start));
}
}
```
```
LinkedList<String> result = new LinkedList<String>();
int back = 0;
while(!stack.isEmpty()){
String top = stack.pop();
```
```
if(top.equals("/.") || top.equals("/")){
//nothing
}else if(top.equals("/..")){
back++;
}else{
if(back > 0){
```
397 | 677


161 Simplify Path

```
back--;
}else{
result.push(top);
}
}
}
```
```
//if empty, return "/"
if(result.isEmpty()){
return "/";
}
```
```
StringBuilder sb = new StringBuilder();
while(!result.isEmpty()){
String s = result.pop();
sb.append(s);
}
```
return sb.toString();
}

398 | 677 Program Creek


## 162 Compare Version Numbers

**162.1 Problem**

Compare two version numbers version 1 and version 2. If version 1 >version 2 return 1 ,
if version 1 <version 2 return - 1 , otherwise return 0. You may assume that the version
strings are non-empty and contain only digits and the. character. The. character does
not represent a decimal point and is used to separate number sequences. Here is an

example of version numbers ordering:

0.1 < 1.1 < 1.2 < 13.37

**162.2 Java Solution**

The tricky part of the problem is to handle cases like 1. 0 and 1. They should be equal.

public int compareVersion(String version1, String version2) {
String[] arr1 = version1.split("\\.");
String[] arr2 = version2.split("\\.");

```
int i=0;
while(i<arr1.length || i<arr2.length){
if(i<arr1.length && i<arr2.length){
if(Integer.parseInt(arr1[i]) < Integer.parseInt(arr2[i])){
return -1;
}else if(Integer.parseInt(arr1[i]) > Integer.parseInt(arr2[i])){
return 1;
}
} else if(i<arr1.length){
if(Integer.parseInt(arr1[i]) != 0){
return 1;
}
} else if(i<arr2.length){
if(Integer.parseInt(arr2[i]) != 0){
return -1;
}
}
```
```
i++;
}
```
```
return 0;
```
399 | 677


162 Compare Version Numbers

### }

400 | 677 Program Creek


## 163 Pascal’s Triangle

Given numRows, generate the first numRows of Pascal’s triangle. For example, given
numRows = 5 , the result should be:

[
[1],
[1,1],
[1,2,1],
[1,3,3,1],
[1,4,6,4,1]
]

**163.1 Java Solution**

public ArrayList<ArrayList<Integer>> generate(int numRows) {
ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
if (numRows <= 0)
return result;

```
ArrayList<Integer> pre = new ArrayList<Integer>();
pre.add(1);
result.add(pre);
```
```
for (int i = 2; i <= numRows; i++) {
ArrayList<Integer> cur = new ArrayList<Integer>();
```
```
cur.add(1); //first
for (int j = 0; j < pre.size() - 1; j++) {
cur.add(pre.get(j) + pre.get(j + 1)); //middle
}
cur.add(1);//last
```
```
result.add(cur);
pre = cur;
}
```
return result;
}

401 | 677



## 164 Pascal’s Triangle II

Given an index k, return the kth row of the Pascal’s triangle. For example, when k =
3 , the row is [ 1 , 3 , 3 , 1 ].

**164.1 Analysis**

This problem is related to Pascal’s Triangle which gets all rows of Pascal’s triangle. In
this problem, only one row is required to return.

**164.2 Java Solution**

public List<Integer> getRow(int rowIndex) {
ArrayList<Integer> result = new ArrayList<Integer>();

```
if (rowIndex < 0)
return result;
```
result.add(1);
for (int i = 1; i <= rowIndex; i++) {
for (int j = result.size() - 2; j >= 0; j--) {
result.set(j + 1, result.get(j) + result.get(j + 1));
}
result.add(1);
}
return result;
}

403 | 677



## 165 Count and Say

**165.1 Problem**

The count-and-say sequence is the sequence of integers beginning as follows: 1 , 11 , 21 ,
1211 , 111221 , ...

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.

Given an integer n, generate the nth sequence.

**165.2 Java Solution**

The problem can be solved by using a simple iteration. See Java solution below:

public String countAndSay(int n) {
if (n <= 0)
return null;

```
String result = "1";
int i = 1;
```
```
while (i < n) {
StringBuilder sb = new StringBuilder();
int count = 1;
for (int j = 1; j < result.length(); j++) {
if (result.charAt(j) == result.charAt(j - 1)) {
count++;
} else {
sb.append(count);
sb.append(result.charAt(j - 1));
count = 1;
}
}
```
```
sb.append(count);
sb.append(result.charAt(result.length() - 1));
result = sb.toString();
i++;
}
```
405 | 677


165 Count and Say

return result;
}

406 | 677 Program Creek


## 166 Basic Calculator

Implement a basic calculator to evaluate a simple expression string.
The expression string may contain open ( and closing parentheses ), the plus + or
minus sign -, non-negative integers and empty spaces.You may assume that the given

expression is always valid.
Some examples: " 1 + 1 " = 2 , "( 1 )" = 1 , "( 1 -( 4 - 5 ))" = 2

**166.1 Analysis**

This problem can be solved by using a stack. We keep pushing element to the stack,
when ’)" is met, calculate the expression up to the first "(".

**166.2 Java Solution**

public int calculate(String s) {
// delte white spaces
s = s.replaceAll(" ", "");

```
Stack<String> stack = new Stack<String>();
char[] arr = s.toCharArray();
```
```
StringBuilder sb = new StringBuilder();
for (int i = 0; i < arr.length; i++) {
if (arr[i] == ’ ’)
continue;
```
```
if (arr[i] >= ’0’ && arr[i] <= ’9’) {
sb.append(arr[i]);
```
```
if (i == arr.length - 1) {
stack.push(sb.toString());
}
} else {
if (sb.length() > 0) {
stack.push(sb.toString());
sb = new StringBuilder();
}
```
```
if (arr[i] != ’)’) {
stack.push(new String(new char[] { arr[i] }));
```
407 | 677


166 Basic Calculator

```
} else {
// when meet ’)’, pop and calculate
ArrayList<String> t = new ArrayList<String>();
while (!stack.isEmpty()) {
String top = stack.pop();
if (top.equals("(")) {
break;
} else {
t.add(0, top);
}
}
```
```
int temp = 0;
if (t.size() == 1) {
temp = Integer.valueOf(t.get(0));
} else {
for (int j = t.size() - 1; j > 0; j = j - 2) {
if (t.get(j - 1).equals("-")) {
temp += 0 - Integer.valueOf(t.get(j));
} else {
temp += Integer.valueOf(t.get(j));
}
}
temp += Integer.valueOf(t.get(0));
}
stack.push(String.valueOf(temp));
}
}
}
```
```
ArrayList<String> t = new ArrayList<String>();
while (!stack.isEmpty()) {
String elem = stack.pop();
t.add(0, elem);
}
```
```
int temp = 0;
for (int i = t.size() - 1; i > 0; i = i - 2) {
if (t.get(i - 1).equals("-")) {
temp += 0 - Integer.valueOf(t.get(i));
} else {
temp += Integer.valueOf(t.get(i));
}
}
temp += Integer.valueOf(t.get(0));
```
return temp;
}

408 | 677 Program Creek


## 167 Basic Calculator II

Implement a basic calculator to evaluate a simple expression string.
The expression string contains only non-negative integers, +, -, *, / operators and
empty spaces. The integer division should truncate toward zero.

```
You may assume that the given expression is always valid.
Some examples: " 3 + 2 * 2 " = 7
```
**167.1 Java Solution**

public int calculate(String s) {
int md=-1; // 0 is m, 1 is d
int sign=1; // 1 is +, -1 is -
int prev=0;
int result=0;

```
for(int i=0; i<s.length(); i++){
char c = s.charAt(i);
if(Character.isDigit(c)){
int num = c-’0’;
while(++i<s.length() && Character.isDigit(s.charAt(i))){
num = num*10+s.charAt(i)-’0’;
}
i--; // back to last digit of number
```
```
if(md==0){
prev = prev*num;
md=-1;
}else if(md==1){
prev = prev / num;
md=-1;
}else{
prev = num;
}
}else if(c==’/’){
md=1;
}else if(c==’*’){
md=0;
}else if(c==’+’){
result = result + sign*prev;
sign=1;
}else if(c==’-’){
```
409 | 677


167 Basic Calculator II

```
result = result + sign*prev;
sign=-1;
}
}
```
result = result + sign*prev;
return result;
}

410 | 677 Program Creek


## 168 Rectangle Area

Find the total area covered by two rectilinear rectangles in a 2 D plane. Each rectangle
is defined by its bottom left corner and top right corner coordinates.

**168.1 Analysis**

This problem can be converted as a overlap internal problem. On the x-axis, there are
(A,C) and (E,G); on the y-axis, there are (F,H) and (B,D). If they do not have overlap,
the total area is the sum of 2 rectangle areas. If they have overlap, the total area should
minus the overlap area.

**168.2 Java Solution**

public int computeArea(int A, int B, int C, int D, int E, int F, int G, int
H) {
if(C<E||G<A )
return (G-E)*(H-F) + (C-A)*(D-B);

```
if(D<F || H<B)
return (G-E)*(H-F) + (C-A)*(D-B);
```
```
int right = Math.min(C,G);
int left = Math.max(A,E);
int top = Math.min(H,D);
int bottom = Math.max(F,B);
```
return (G-E)*(H-F) + (C-A)*(D-B) - (right-left)*(top-bottom);
}

411 | 677



## 169 Reverse Vowels of a String

Write a function that takes a string as input and reverse only the vowels of a string.

**169.1 Java Solution**

this is a simple problem which can be solved by using two pointers scanning from
beginning and end of the array.

public String reverseVowels(String s) {
ArrayList<Character> vowList = new ArrayList<Character>();
vowList.add(’a’);
vowList.add(’e’);
vowList.add(’i’);
vowList.add(’o’);
vowList.add(’u’);
vowList.add(’A’);
vowList.add(’E’);
vowList.add(’I’);
vowList.add(’O’);
vowList.add(’U’);

```
char[] arr = s.toCharArray();
```
```
int i=0;
int j=s.length()-1;
```
```
while(i<j){
if(!vowList.contains(arr[i])){
i++;
continue;
}
```
```
if(!vowList.contains(arr[j])){
j--;
continue;
}
```
```
char t = arr[i];
arr[i]=arr[j];
arr[j]=t;
```
```
i++;
j--;
```
413 | 677


169 Reverse Vowels of a String

### }

return new String(arr);
}

414 | 677 Program Creek


## 170 Find Peak Element

A peak element is an element that is greater than its neighbors. Given an input array
where num[i] 6 =num[i+ 1 ], find a peak element and return its index. The array may
contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that num[- 1 ] = num[n] = -∞. For example, in array [ 1 , 2 , 3 , 1 ], 3 is

a peak element and your function should return the index number 2.

**170.1 Thoughts**

This is a very simple problem. We can scan the array and find any element that is

greater can its previous and next. The first and last element are handled separately.

**170.2 Java Solution**

public class Solution {
public int findPeakElement(int[] num) {
int max = num[0];
int index = 0;
for(int i=1; i<=num.length-2; i++){
int prev = num[i-1];
int curr = num[i];
int next = num[i+1];

```
if(curr > prev && curr > next && curr > max){
index = i;
max = curr;
}
}
```
```
if(num[num.length-1] > max){
return num.length-1;
}
```
return index;
}
}

415 | 677



## 171 Integer to English Words Contents

Convert a non-negative integer to its english words representation. Given input is
guaranteed to be less than 231 - 1.

For example, 123 ->"One Hundred Twenty Three" 12345 ->"Twelve Thousand Three
Hundred Forty Five"

**171.1 Java Solution**

This problem is straightforward, but the corner cases should be considered carefully.

public class Solution {
HashMap<Integer, String> map = new HashMap<Integer, String>();

```
public String numberToWords(int num) {
fillMap();
StringBuilder sb = new StringBuilder();
```
```
if(num==0){
return map.get(0);
}
```
```
if(num >= 1000000000){
int extra = num/1000000000;
sb.append(convert(extra) + " Billion");
num = num%1000000000;
}
```
```
if(num >= 1000000){
int extra = num/1000000;
sb.append(convert(extra) + " Million");
num = num%1000000;
}
```
```
if(num >= 1000){
int extra = num/1000;
sb.append(convert(extra) + " Thousand");
num = num%1000;
}
```
```
if(num > 0){
sb.append(convert(num));
}
```
417 | 677


171 Integer to English Words

```
return sb.toString().trim();
}
```
```
public String convert(int num){
```
```
StringBuilder sb = new StringBuilder();
```
```
if(num>=100){
int numHundred = num/100;
sb.append(" " +map.get(numHundred)+ " Hundred");
num=num%100;
}
```
```
if(num > 0){
if(num>0 && num<=20){
sb.append(" "+map.get(num));
}else{
int numTen = num/10;
sb.append(" "+map.get(numTen*10));
```
```
int numOne=num%10;
if(numOne>0){
sb.append(" " + map.get(numOne));
}
}
}
```
```
return sb.toString();
}
```
```
public void fillMap(){
map.put(0, "Zero");
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");
map.put(4, "Four");
map.put(5, "Five");
map.put(6, "Six");
map.put(7, "Seven");
map.put(8, "Eight");
map.put(9, "Nine");
map.put(10, "Ten");
map.put(11, "Eleven");
map.put(12, "Twelve");
map.put(13, "Thirteen");
map.put(14, "Fourteen");
map.put(15, "Fifteen");
map.put(16, "Sixteen");
map.put(17, "Seventeen");
```
418 | 677 Program Creek


```
171 Integer to English Words
```
map.put(18, "Eighteen");
map.put(19, "Nineteen");
map.put(20, "Twenty");
map.put(30, "Thirty");
map.put(40, "Forty");
map.put(50, "Fifty");
map.put(60, "Sixty");
map.put(70, "Seventy");
map.put(80, "Eighty");
map.put(90, "Ninety");
}
}

Program Creek 419 | 677



## 172 Text Justification

Given an array of words and a length L, format the text such that each line has exactly

L characters and is fully (left and right) justified. You should pack your words in
a greedy approach; that is, pack as many words as you can in each line. Pad extra
spaces ’ ’ when necessary so that each line has exactly L characters. Extra spaces
between words should be distributed as evenly as possible. If the number of spaces

on a line do not divide evenly between words, the empty slots on the left will be
assigned more spaces than the slots on the right. For the last line of text, it should be
left justified and no extra space is inserted between words.
For example, words: ["This", "is", "an", "example", "of", "text", "justification."] L: 16.
Return the formatted lines as: [ "This is an", "example of text", "justification. " ]

**172.1 Java Solution**

There is not a special algorithm required to solve this problem. To correctly solve this
problem, the following situations should be taken care of: 1. if a line has only one

word and the word’s length is less than max width, we need to fill the left part with
spaces. 2. how to distribute extra spaces for each words when the number of spaces
can not be evenly distributed to each word.

public List<String> fullJustify(String[] words, int maxWidth) {
List<String> result = new ArrayList<String>();

```
if(words==null || words.length==0){
return result;
}
```
```
int count=0;
int last=0;
ArrayList<String> list = new ArrayList<String>();
for(int i=0; i<words.length; i++){
count = count + words[i].length();
```
```
if(count+i-last>maxWidth){
int wordsLen = count-words[i].length();
int spaceLen = maxWidth-wordsLen;
int eachLen = 1;
int extraLen = 0;
```
```
if(i-last-1>0){
```
421 | 677


172 Text Justification

```
eachLen = spaceLen/(i-last-1);
extraLen = spaceLen%(i-last-1);
}
```
```
StringBuilder sb = new StringBuilder();
```
```
for(int k=last; k<i-1; k++){
sb.append(words[k]);
```
```
int ce = 0;
while(ce<eachLen){
sb.append(" ");
ce++;
}
```
```
if(extraLen>0){
sb.append(" ");
extraLen--;
}
}
```
```
sb.append(words[i-1]);//last words in the line
//if only one word in this line, need to fill left with space
while(sb.length()<maxWidth){
sb.append(" ");
}
```
```
result.add(sb.toString());
```
```
last = i;
count=words[i].length();
}
}
```
```
int lastLen = 0;
StringBuilder sb = new StringBuilder();
```
```
for(int i=last; i<words.length-1; i++){
count = count+words[i].length();
sb.append(words[i]+" ");
}
```
```
sb.append(words[words.length-1]);
int d=0;
while(sb.length()<maxWidth){
sb.append(" ");
}
result.add(sb.toString());
```
```
return result;
```
422 | 677 Program Creek


```
172 Text Justification
```
### }

Program Creek 423 | 677



## 173 Gas Station

There are N gas stations along a circular route, where the amount of gas at station i is
gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from

station i to its next station (i+ 1 ). You begin the journey with an empty tank at one of
the gas stations.
Return the starting gas station’s index if you can travel around the circuit once,
otherwise return - 1.

**173.1 Analysis**

To solve this problem, we need to understand and use the following 2 facts: 1 ) if the
sum of gas >= the sum of cost, then the circle can be completed. 2 ) if A can not reach

C in a the sequence of A–>B–>C, then B can not make it either.
Proof of fact 2 :

If gas[A] < cost[A], then A can not even reach B.
So to reach C from A, gas[A] must >= cost[A].
Given that A can not reach C, we have gas[A] + gas[B] < cost[A] + cost[B],
and gas[A] >= cost[A],
Therefore, gas[B] < cost[B], i.e., B can not reach C.

**173.2 Java Solution**

public int canCompleteCircuit(int[] gas, int[] cost) {
int sumRemaining = 0; // track current remaining
int total = 0; // track total remaining
int start = 0;

```
for (int i = 0; i < gas.length; i++) {
```
425 | 677


173 Gas Station

```
int remaining = gas[i] - cost[i];
```
```
//if sum remaining of (i-1) >= 0, continue
if (sumRemaining >= 0) {
sumRemaining += remaining;
//otherwise, reset start index to be current
} else {
sumRemaining = remaining;
start = i;
}
total += remaining;
}
```
if (total >= 0){
return start;
}else{
return -1;
}
}

426 | 677 Program Creek


## 174 Self Crossing

**174.1 Analysis**

This problem can be easily solved if the three self crossing cases are summarized well.
Here are the three self crossing cases. There are no other self crossing situations based
on the restrictions of counter-clockwise.

**174.2 Java Solution**

Writing the solution is straightforward once the 3 self crossing cases are identified.

public boolean isSelfCrossing(int[] x) {
if(x==null || x.length<=3)
return false;

```
for(int i=3; i<x.length; i++){
if(x[i-3] >= x[i-1] && x[i-2]<=x[i]){
return true;
}
```
427 | 677


174 Self Crossing

```
if(i>=4 && x[i-4]+x[i]>=x[i-2] && x[i-3]==x[i-1]) {
return true;
}
```
```
if(i>=5 && x[i-5]<=x[i-3] && x[i]<=x[i-2]&& x[i-1]<=x[i-3] &&
x[i-4]<=x[i-2] && x[i-1]>=x[i-3]-x[i-5] && x[i]>=x[i-2]-x[i-4]){
return true;
}
}
```
return false;
}

428 | 677 Program Creek


## 175 Patching Array

Given a sorted positive integer array nums and an integer n, add/patch elements to
the array such that any number in range [ 1 , n] inclusive can be formed by the sum of

some elements in the array. Return the minimum number of patches required.
Example 1 : nums = [ 1 , 3 ], n = 6 Return 1.

**175.1 Analysis**

Let miss be the smallest number that can not be formed by the sum of elements in the

array. All elements in [ 0 , miss) can be formed. The miss value starts with 1. If the next
number nums[i]<=miss, then the boundary is increased to be [ 0 , miss+nums[i]), be-
cause all numbers between the boundaries can be formed; if next number nums[i]>miss,
that means there is a gap and we need to insert a number, inserting miss itself is a the
choice because its boundary doubles and cover every number between the boundaries

[ 0 , miss+miss).
Here is an example. Given nums=[ 1 , 4 , 10 ] and n= 50.

miss=1;
i=0, nums[i]<=miss, then miss=1+1=2
i=1, nums[i]>2, then miss = miss+miss = 4
i=1, nums[i]<=miss, then miss = miss+num[i] = 8
i=2, nums[i]>miss, then miss = miss+miss = 16
i=2, nums[i]>miss, then miss = miss+miss = 32
i=2, nums[i]>miss, then miss = miss+miss = 64
64 > 50. Done! 4 elements are added!

**175.2 Java Solution**

Writing the code is trivial, once we understand the algorithm.

public int minPatches(int[] nums, int n) {
long miss = 1;
int count = 0;
int i = 0;

```
while(miss <= n){
if(i<nums.length && nums[i] <= miss){
miss = miss + nums[i];
i++;
}else{
```
429 | 677


175 Patching Array

```
miss += miss;
count++;
}
}
```
return count;
}

430 | 677 Program Creek


## 176 Nim Game

ou are playing the following Nim Game with your friend: There is a heap of stones
on the table, each time one of you take turns to remove 1 to 3 stones. The one who
removes the last stone will be the winner. You will take the first turn to remove the
stones.

**176.1 Analysis**

**176.2 Java Solution**

public boolean canWinNim(int n) {
return n%4>0;
}

431 | 677



## 177 Bulb Switcher

There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn

off every second bulb. On the third round, you toggle every third bulb (turning on if
it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth
round, you only toggle the last bulb. Find how many bulbs are on after n rounds.

**177.1 Analysis**

By using some examples we can find out the number of switches for each bulb:

1 -> 1 (1)
2 -> 2 (1 2)
3 -> 2 (1 3)
4 -> 3 (1 2 4)
5 -> 2 (1 5)
6 -> 4 (1 2 3 6)
7 -> 2 (1 7)
8 -> 4 (1 2 4 8)
9 -> 3 (1 3 9)

So only (i*i)th element has odd number of switches and they are on. The problem

is now get all the square numbers.

**177.2 Java Solution 1 - Naive**

public int bulbSwitch(int n) {
int count=0;
for(int i=1; i<=n; i++){
int numSwitch = helper(i);
if(numSwitch%2 ==1)
count++;
}

return count;
}

public int helper(int n){
int count=0;
for(int i=1; i<=n; i++){
if(n%i==0)

433 | 677


177 Bulb Switcher

count++;
}
return count;
}

**177.3 Java Solution 2 - Simplified**

public int bulbSwitch(int n) {
return (int)Math.sqrt(n);
}

434 | 677 Program Creek


## 178 Pain Fence

There is a fence with n posts, each post can be painted with one of the k colors. You
have to paint all the posts such that no more than two adjacent fence posts have the
same color. Return the total number of ways you can paint the fence.

**178.1 Java Solution**

The key to solve this problem is finding this relation.
f(n) = (k- 1 )(f(n- 1 )+f(n- 2 ))
Assuming there are 3 posts, if the first one and the second one has the same color,

then the third one has k- 1 options. The first and second together has k options. If the
first and the second do not have same color, the total is k * (k- 1 ), then the third one
has k options. Therefore, f( 3 ) = (k- 1 )*k + k*(k- 1 )*k = (k- 1 )(k+k*k)

public int numWays(int n, int k) {
int dp[] = {0, k , k*k, 0};

```
if(n <= 2)
return dp[n];
```
```
for(int i = 2; i < n; i++){
dp[3] = (k - 1)* (dp[1] + dp[2]);
dp[1] = dp[2];
dp[2] = dp[3];
}
```
return dp[3];
}

435 | 677



## 179 Nested List Weight Sum

Given a nested list of integers, return the sum of all integers in the list weighted by
their depth.
Each element is either an integer, or a list – whose elements may also be integers or
other lists.

Example 1 : Given the list [[ 1 , 1 ], 2 ,[ 1 , 1 ]], return 10. (four 1 ’s at depth 2 , one 2 at depth
1 )

**179.1 Java Solution**

public int depthSum(List<NestedInteger> nestedList) {
return helper(nestedList, 1);
}

public int helper(List<NestedInteger> nestedList, int depth){
if(nestedList==null||nestedList.size()==0)
return 0;

```
int sum=0;
for(NestedInteger ni: nestedList){
if(ni.isInteger()){
sum += ni.getInteger()* depth;
}else{
sum += helper(ni.getList(), depth+1);
}
}
```
return sum;
}

437 | 677

